<h1 id="calculator-assignment-instructions">Calculator Assignment
Instructions</h1>
<p>You are implementing a 4-function calculator. Think of a simple casio
or the calculator. The display shows the current number you are typing,
or an intermediate calculation result. It does not display any operands
or other info, except the occasional “error” when appropriate. The
skeleton of the program is given to you; you will update the controller
and model to add functionality. First you will implement simple
left-to-right evaluation using two stacks. Second you will implement
operator precedence. Finally you will add extensions of your choice.</p>
<h2 id="overview-of-architecture">Overview of Architecture</h2>
<p>This calculator application follows the Model-View-Controller (MVC)
design pattern:</p>
<ol type="1">
<li><strong>Model (<code>CalculatorModel.java</code>)</strong>: Manages
the data and calculation logic, including operand and operator
stacks.</li>
<li><strong>View (<code>CalculatorUI.java</code>)</strong>: Handles the
user interface elements including display and buttons.</li>
<li><strong>Controller
(<code>CalculatorController.java</code>)</strong>: Processes user input
and coordinates between the model and view.</li>
<li><strong>Main Application (<code>Calculator.java</code>)</strong>:
Entry point that initializes the MVC components.</li>
</ol>
<p>Supporting classes include: - <code>Operator.java</code>: Constants
for calculator operations - <code>DebugStack.java</code>: Extended Stack
implementation for debugging</p>
<figure>
<img src="calculator.png" style="width:25.0%"
alt="Calculator Interface" />
<figcaption aria-hidden="true">Calculator Interface</figcaption>
</figure>
<h2 id="operand-and-operator-stacks">Operand and Operator Stacks</h2>
<p>The calculator uses two stacks to manage calculations: -
<strong>Operand Stack</strong>: Stores numeric values (operands) for
calculations - <strong>Operator Stack</strong>: Stores operators (+, -,
×, ÷, etc.)</p>
<p>These stacks allow for sequential processing of operations. When
operations are performed, values are popped from the stacks,
calculations are made, and results are pushed back.</p>
<h2 id="methods-to-complete">Methods to Complete</h2>
<h3 id="in-calculatorcontroller.java">In
<code>CalculatorController.java</code>:</h3>
<ol type="1">
<li><strong><code>handleClear()</code></strong>: Reset the calculator
state, clear display and stacks.</li>
<li><strong><code>handleBackspace()</code></strong>: Remove the last
character from the display.</li>
</ol>
<h3 id="in-calculatormodel.java">In
<code>CalculatorModel.java</code>:</h3>
<ol type="1">
<li><strong><code>appendDecimalPoint()</code></strong>: Add a decimal
point to the current display value if not already present.</li>
<li><strong><code>backspace()</code></strong>: Remove the last character
from the display value.</li>
<li><strong><code>calculate()</code></strong>: Perform one calculation
using operands and operators from the stacks.</li>
<li><strong><code>reduce(String operator)</code></strong>: Calls
<code>calculate</code> one or more times based on the current stack
contents</li>
<li><strong><code>precedence(String operator)</code></strong>: Return
the precedence level of an operator (for Phase 2).</li>
</ol>
<h3 id="in-debugstack.java">In <code>DebugStack.java</code>:</h3>
<p>Extend the Stack class to print stack contents after push, pop, and
clear operations. For example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">@Override</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> E <span class="fu">push</span><span class="op">(</span>E item<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    E result <span class="op">=</span> <span class="kw">super</span><span class="op">.</span><span class="fu">push</span><span class="op">(</span>item<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Push: &quot;</span> <span class="op">+</span> item <span class="op">+</span> <span class="st">&quot;, Stack: &quot;</span> <span class="op">+</span> <span class="kw">this</span><span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="implementation-phases">Implementation Phases</h2>
<h3 id="phase-1-basic-functionality">Phase 1: Basic Functionality</h3>
<ul>
<li>Implement all the required methods</li>
<li>Support basic operations (+, -, ×, ÷)</li>
<li>Add support for constants π and e (hint: handle in the controller
similar to digits)</li>
<li>Process calculations left-to-right without operator precedence</li>
<li>Implement DebugStack for debugging</li>
</ul>
<h3 id="phase-2-operator-precedence">Phase 2: Operator Precedence</h3>
<ul>
<li>Implement the <code>precedence()</code> method to assign priorities
to operators</li>
<li>Modify <code>reduce()</code> and related methods to respect operator
precedence</li>
<li>Ensure that multiplication/division are performed before
addition/subtraction</li>
</ul>
<h3 id="phase-3-extensions-pick-one-or-more">Phase 3: Extensions (Pick
one or more)</h3>
<ul>
<li>Implement parentheses support</li>
<li>Add scientific functions (sin, cos, tan, sqrt, etc.)</li>
<li>Add a 2nd button for arcsin, arccos, etc.</li>
<li>Implement memory functions (M+, M-, MR, MC)</li>
<li>Create a graphing feature for simple functions</li>
<li>Support different number systems (binary, octal, hex)</li>
<li>Add unit conversions</li>
<li>Your idea!</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>The <code>DebugStack</code> implementation should be helpful for
visualizing how the stacks change during operations</li>
<li>Remember that in Phase 1, operations are performed left-to-right (no
operator precedence)</li>
<li>For constants like π and e, you’ll need to handle these specially in
the controller</li>
</ul>
<h2
id="example-calculating-a-left-to-right-expression-using-two-stacks">Example:
Calculating a Left-to-Right Expression Using Two Stacks</h2>
<p>Here’s a simple example of how to calculate the expression
<code>3 + 425 × 2</code> using the two-stack approach with left-to-right
evaluation (Phase 1 approach without operator precedence):</p>
<h3 id="initial-state">Initial State:</h3>
<ul>
<li>Operand Stack: [ ]</li>
<li>Operator Stack: [ ]</li>
<li>Display: “0”</li>
</ul>
<h3 id="user-enters-3">User enters “3”:</h3>
<ul>
<li>Display: “3”</li>
<li>No stack changes yet (value is only in display)</li>
</ul>
<h3 id="user-enters">User enters “+”:</h3>
<ul>
<li>Read current display value (3) and push to Operand Stack</li>
<li>Push + to Operator Stack</li>
<li>Operand Stack: [3]</li>
<li>Operator Stack: [+]</li>
<li>Display: “3”</li>
</ul>
<h3 id="user-enters-4">User enters “4”:</h3>
<ul>
<li>Display: “4”</li>
<li>No stack changes yet</li>
</ul>
<h3 id="user-enters-2">User enters “2”:</h3>
<ul>
<li>Display: “42” (digits accumulate in the display)</li>
<li>No stack changes yet</li>
</ul>
<h3 id="user-enters-5">User enters “5”:</h3>
<ul>
<li>Display: “425” (digits accumulate in the display)</li>
<li>No stack changes yet</li>
</ul>
<h3 id="user-enters-1">User enters “×”:</h3>
<ul>
<li><p>Read current display value (425) and push to Operand
Stack</p></li>
<li><p>Operand Stack: [3, 425]</p></li>
<li><p>Operator Stack: [+]</p></li>
<li><p>Since we have 2 operands and 1 operator, perform calculation:</p>
<ul>
<li>Pop 425 and 3 from Operand Stack</li>
<li>Pop + from Operator Stack</li>
<li>Calculate: 3 + 425 = 428</li>
<li>Push 428 to Operand Stack</li>
</ul></li>
<li><p>After reduction, push × to Operator Stack</p></li>
<li><p>Operand Stack: [428]</p></li>
<li><p>Operator Stack: [×]</p></li>
<li><p>Display: “428”</p></li>
</ul>
<h3 id="user-enters-2-1">User enters “2”:</h3>
<ul>
<li>Display: “2”</li>
<li>No stack changes yet (value is only in display)</li>
</ul>
<h3 id="user-enters-6">User enters “=”:</h3>
<ul>
<li><p>Read current display value (2) and push to Operand Stack</p></li>
<li><p>Operand Stack: [428, 2]</p></li>
<li><p>Operator Stack: [×]</p></li>
<li><p>Since we have 2 operands and 1 operator, perform calculation:</p>
<ul>
<li>Pop 2 and 428 from Operand Stack</li>
<li>Pop × from Operator Stack</li>
<li>Calculate: 428 × 2 = 856</li>
<li>Push 856 to Operand Stack</li>
</ul></li>
<li><p>Since “=” was pressed, we don’t push it to the Operator
Stack</p></li>
<li><p>Operand Stack: [856]</p></li>
<li><p>Operator Stack: [ ]</p></li>
<li><p>Display: “856”</p></li>
</ul>
<p>Note: In Phase 1, operations are performed strictly left-to-right as
shown above (3 + 4 × 2 = 14). In Phase 2 with operator precedence,
multiplication would be performed before addition, resulting in 3 + (4 ×
2) = 11.</p>
