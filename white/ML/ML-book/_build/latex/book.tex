%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Setup}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{My sample book}
\date{Oct 03, 2024}
\release{}
\author{The Jupyter Book Community}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
This is a small sample book to give you a feel for how book content is
structured.
It shows off a few of the major file types, as well as some sample content.
It does not go in\sphinxhyphen{}depth into any particular topic \sphinxhyphen{} check out \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation} for more information.

\sphinxAtStartPar
Check out the content pages bundled with this sample book to see more.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Setup

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/hw01::doc}]{\sphinxcrossref{Homework 01}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/hw02::doc}]{\sphinxcrossref{Exploring data}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/wsl::doc}]{\sphinxcrossref{Fixing WSL}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/cw03::doc}]{\sphinxcrossref{August 28}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Measures of Closeness

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Bayes_Theorem_Student::doc}]{\sphinxcrossref{Bayes’ Theorem}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/jupyter-python-intro::doc}]{\sphinxcrossref{Quick Jupyter Intro and Python Loops}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Linear_regression_derivation::doc}]{\sphinxcrossref{Linear Regression}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/least-squares-01::doc}]{\sphinxcrossref{Linear Least Squares}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Correlation_Coefficient::doc}]{\sphinxcrossref{Correlation Coefficient}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Linear Algebra in Python

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Matrices-student::doc}]{\sphinxcrossref{Linear Algebra and Python Lists}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Intro_to_Matrices_in_NumPy::doc}]{\sphinxcrossref{Introduction to Matrices in NumPy}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Matrices_Index_Warmup-Student::doc}]{\sphinxcrossref{Matrix indices warmup}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Gaussian_Elimination-student::doc}]{\sphinxcrossref{Gaussian Elimination}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/LogLogRegression::doc}]{\sphinxcrossref{Log\sphinxhyphen{}Log Regression}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Strassen-Lab::doc}]{\sphinxcrossref{Strassen’s Algorithm (Optional Extension)}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Gauss::doc}]{\sphinxcrossref{Gauss Presentation}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/inversion::doc}]{\sphinxcrossref{Matrix Inversion}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Running_Time_Analysis::doc}]{\sphinxcrossref{Running Time Analysis}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Next Steps

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/reading::doc}]{\sphinxcrossref{Reading for Research}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/Hobo_Student::doc}]{\sphinxcrossref{Hobo Data, Student Version}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{lessons/ML_Book_Club::doc}]{\sphinxcrossref{ML Book Club}}}

\end{itemize}
\end{itemize}

\sphinxstepscope


\part{Setup}

\sphinxstepscope


\chapter{Homework 01}
\label{\detokenize{lessons/hw01:homework-01}}\label{\detokenize{lessons/hw01::doc}}
\sphinxAtStartPar
Goals for the day
\begin{itemize}
\item {} 
\sphinxAtStartPar
Set up python dev environment on school or personal laptop

\item {} 
\sphinxAtStartPar
Raspberry Pi Project

\item {} 
\sphinxAtStartPar
Money List

\end{itemize}


\section{Set up dev environment}
\label{\detokenize{lessons/hw01:set-up-dev-environment}}
\sphinxAtStartPar
You need a decent amount of software to do real machine learning and your life will be much
easier if we all have the same dev environment, to a certain degree. Here are steps we can take to try to get on the same page (these instructions are not perfect and if you get stuck, try to figure it out or we’ll fix it in class)
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install a real text editor (VSCode, Atom, Sublime, \sphinxcode{\sphinxupquote{vim}}, \sphinxcode{\sphinxupquote{emacs}}, …). If you don’t know or care, \sphinxhref{https://code.visualstudio.com/download}{do VSCode}.

\item {} 
\sphinxAtStartPar
On a Windows machine, install \sphinxcode{\sphinxupquote{WSL}} (Windows Subsystem for Linux) following \sphinxhref{https://learn.microsoft.com/en-us/windows/wsl/install}{these instructions}. Be sure to select Ubuntu 22 for your distribution (unless you are sure you will never need to ask me for help).

\item {} 
\sphinxAtStartPar
Inside linux (WSL or Mac/Linux bash shell), install \sphinxcode{\sphinxupquote{asdf}} (a version manager for executables) according to \sphinxhref{https://asdf-vm.com/guide/getting-started.html}{these instructions}.

\item {} 
\sphinxAtStartPar
Set up python
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Restart your shell (in WSL or Mac/Linux bash shell)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asdf plugin add python}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asdf install python 3.11.9}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{asdf global python 3.11.9}} or \sphinxcode{\sphinxupquote{asdf local python 3.11.9}}

\item {} 
\sphinxAtStartPar
Make a directory for your ML projects \sphinxcode{\sphinxupquote{mkdir \textasciitilde{}/ml}} then open the directory \sphinxcode{\sphinxupquote{cd \textasciitilde{}/ml}} and set up a virtual environment (next)

\end{enumerate}

\item {} 
\sphinxAtStartPar
Set up a virtual environment (a directory with specific version of python and libraries to use in your projects.)
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
In your ml directory (\sphinxcode{\sphinxupquote{cd \textasciitilde{}/ml}})

\item {} 
\sphinxAtStartPar
Ensure you’re running python 3.11.9: \sphinxcode{\sphinxupquote{python \sphinxhyphen{}\sphinxhyphen{}version}} (if not redo step 4.4 above)

\item {} 
\sphinxAtStartPar
Create a virtual environment \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m venv env}} (This creates a directory named \sphinxcode{\sphinxupquote{env}} with a local install of python)

\item {} 
\sphinxAtStartPar
Activate the environment \sphinxcode{\sphinxupquote{source env/bin/activate}}

\item {} 
\sphinxAtStartPar
Copy \DUrole{xref,download,myst}{this file} to your folder \sphinxcode{\sphinxupquote{\textasciitilde{}/ml}} as \sphinxcode{\sphinxupquote{requirements.txt}}.

\item {} 
\sphinxAtStartPar
Install the libraries \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}r requirements.txt}}

\item {} 
\sphinxAtStartPar
Everything should install with no errors (warnings are OK.)

\item {} 
\sphinxAtStartPar
See if jupyter is working: \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}lab}} (should open a browser)

\end{enumerate}

\end{enumerate}

\sphinxAtStartPar
\sphinxstyleemphasis{Action Item}: (As much as possible…) Set up a functioning python 3.11.9 dev environment with Jupyter and a text editor. Use the provided \sphinxcode{\sphinxupquote{requirements.txt}} file to create a virtual environment with the packages needed for class.


\subsection{Optional (last resort)}
\label{\detokenize{lessons/hw01:optional-last-resort}}
\sphinxAtStartPar
If the WSL route is too complicated for now or just not working, Anaconda will get you up
and running. The reason this is not recommended is that Anaconda installs a LOT of software and does a LOT of setup behind the scenes. And when you want to change something, or bypass Anaconda for a reason, it can be tricky to disable it. That said, it is very popular and good at what it does.

\sphinxAtStartPar
Install \sphinxhref{https://anaconda.cloud/api/iam/email/verified/1a8a9aa0-e28f-4ceb-9ca4-b29dde699d5c}{Anaconda for Windows}


\section{Raspberry Pi Project}
\label{\detokenize{lessons/hw01:raspberry-pi-project}}
\sphinxAtStartPar
I have about 25 Raspberry Pi 3s and would like you to do \sphinxstyleemphasis{something} with one. Go home,
read about them, find a fun project or something to install or make and come tell me what
it is. If I approve, then I’ll give you a pi for a few days to make it work. In addition to the Pi we have sensors and peripherals and things so if you want to do something fancy we might be able to find the stuff for it. Just note: this is not a \sphinxstyleemphasis{big} project. Just a quick thing to get something up and running.

\sphinxAtStartPar
You will need a monitor, HDMI cable, keyboard and wired mouse to complete the initial Pi setup. After that it can run “headless” on your home network. If you don’t have these things at home, we can probably get you to do the initial setup here at school.

\sphinxAtStartPar
\sphinxstyleemphasis{Action Item}: come to class with some ideas for projects. Be ready to discuss with friends and/or the teacher.


\section{The Money List}
\label{\detokenize{lessons/hw01:the-money-list}}
\sphinxAtStartPar
Your money list is a list of ideas that will make you money! You’ll add to it all year. It starts off simple: write down things that annoy you and think of ways to fix them. The annoying things can be literally anything (that’s the point of brainstorming) and the “ways to fix them” can be outlandish. But, the goal is to occasionally stumble on an idea that is generally useful to lots of people and whose solution is something you can work on. If your idea is good enough and your solution works, then sell it. Make money!

\sphinxAtStartPar
\sphinxstyleemphasis{Action Item}: Start the list somewhere semi\sphinxhyphen{}permanent. In a notebook, on your computer, Google Drive, or your phone. (the best might be a cloud file shared to multiple devices). Try to find 3 ideas by next class. Don’t be too picky

\sphinxstepscope


\chapter{Exploring data}
\label{\detokenize{lessons/hw02:exploring-data}}\label{\detokenize{lessons/hw02::doc}}
\sphinxAtStartPar
The file {\hyperref[\detokenize{lessons/hw02:../data/weather-daylight.csv}]{\sphinxcrossref{\DUrole{xref,myst}{weather\sphinxhyphen{}daylight.csv}}}} contains observational weather data for Leesburg, VA. We want to
analyze the hypothesis “the fall of 2023 had more cloudy and rainy weekends than normal.”
As a class, let’s look at the data and talk about our ideas for processing it. Open this file in Microsoft Excel, or something like it.

\sphinxAtStartPar
What questions do you have? What pre\sphinxhyphen{}processing is relevant?
What types of calculations would support or refute the claim? Do you know how to make
those calculations in Python or another language or tool?


\section{Look at It! LOOK at IT!}
\label{\detokenize{lessons/hw02:look-at-it-look-at-it}}
\sphinxAtStartPar
(Bonus points if you know the Seinfeld reference). The first thing to do is just look at the data set. What do you see? Here are some questions you should ask?
\begin{itemize}
\item {} 
\sphinxAtStartPar
How many rows, how many columns?

\item {} 
\sphinxAtStartPar
Is the data rectangular (are all rows the same length?)

\item {} 
\sphinxAtStartPar
What types of data? (Numerical, categorical?)

\item {} 
\sphinxAtStartPar
What domain of data (numerical: min and max, precision, mean, variance; categorical: number of categories)

\item {} 
\sphinxAtStartPar
Any missing data?

\item {} 
\sphinxAtStartPar
Is the file clean (read/write errors? paragraphs of text before or after? anything else weird?)

\item {} 
\sphinxAtStartPar
Find meaning: What do the columns are rows mean? Are there headers? Are they defined?

\item {} 
\sphinxAtStartPar
What is the source? Is this data reliable?

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{{\hyperref[\detokenize{lessons/hw02:../data/weather-columns.md}]{\sphinxcrossref{\DUrole{xref,myst}{Weather columns}}}}}

\end{itemize}


\section{Analyse it}
\label{\detokenize{lessons/hw02:analyse-it}}\begin{itemize}
\item {} 
\sphinxAtStartPar
What question are you asking?

\item {} 
\sphinxAtStartPar
What does the data say about the question?

\item {} 
\sphinxAtStartPar
Repeat the last 2 steps as needed!

\end{itemize}


\section{Jupyter Notebook}
\label{\detokenize{lessons/hw02:jupyter-notebook}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Follow this link to a \sphinxhref{https://mybinder.org/v2/gh/AET-CS/ML-binder/HEAD?labpath=weather.ipynb}{jupyter notebook}

\item {} 
\sphinxAtStartPar
I believe you can save and open notebooks from this interface, as long as you are using the same Chrome profile and history (it uses local storage to save state).

\end{itemize}


\section{Homework}
\label{\detokenize{lessons/hw02:homework}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Open the jupyter notebook above from class on \sphinxhref{http://mybinder.org}{mybinder.org} (or you can run it locally as \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}lab}} in your \sphinxcode{\sphinxupquote{ml}} folder on WSL. Make sure to copy the notebook to your \sphinxcode{\sphinxupquote{ml}} folder first – \DUrole{std,std-doc}{download it}).

\item {} 
\sphinxAtStartPar
Devise a different way to analyse the question about the weather in Leesburg and try to analyse it using pandas. What conclusion can you draw?

\item {} 
\sphinxAtStartPar
Make some interesting plots from this dataset. You will need to read up on plotting in dataframes using pandas and possibly some things about pyplot.

\item {} 
\sphinxAtStartPar
Consider the {\hyperref[\detokenize{lessons/hw02:../data/london_weather.csv}]{\sphinxcrossref{\DUrole{xref,myst}{London Weather dataset}}}}. Investigate the question “Has the weather in London gotten worse in the last 50 years?” Analyse the data and make a claim that you can support. Source for dataset: \sphinxurl{https://www.kaggle.com/datasets/emmanuelfwerr/london-weather-data}, which retrieved the data from \sphinxurl{https://www.ecad.eu/dailydata/index.php}.

\item {} 
\sphinxAtStartPar
Be prepared to discuss your findings and present to the class if asked to! (Your research doesn’t need to be profound but I do need to see you’re learning how to use \sphinxcode{\sphinxupquote{pandas}}).

\item {} 
\sphinxAtStartPar
To be safe, you should download any notebooks you create on \sphinxcode{\sphinxupquote{mybinder.org}} because I don’t know how reliable its storage system is.

\item {} 
\sphinxAtStartPar
WSL Problems: {\hyperref[\detokenize{lessons/wsl::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{Fix posted!}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{In general} I’m always happy to answer homework questions. \sphinxstyleemphasis{Remind} is the best way to reach me in the evening so don’t shy away from asking. If I can’t help, I’ll say so. Otherwise I’ll try my best!

\end{itemize}

\sphinxstepscope


\chapter{Fixing WSL}
\label{\detokenize{lessons/wsl:fixing-wsl}}\label{\detokenize{lessons/wsl::doc}}
\sphinxAtStartPar
If you tried my first instructions and ran into some kind of python packaging error (looks like mysql is a culprit), here’s a patch

\sphinxAtStartPar
First, you should switch to your \sphinxcode{\sphinxupquote{ml}} folder in WSL and delete the old environment.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }ml\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} or whatever}
\PYGZdl{}\PYG{+w}{ }deactivate\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} may not do anything if you didn\PYGZsq{}t activate the env}
\PYGZdl{}\PYG{+w}{ }rm\PYG{+w}{ }\PYGZhy{}rf\PYG{+w}{ }env\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} this deletes the old environment}
\PYGZdl{}\PYG{+w}{ }asdf\PYG{+w}{ }\PYG{n+nb}{local}\PYG{+w}{ }python\PYG{+w}{ }\PYG{l+m}{3}.11.9\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} make sure you\PYGZsq{}re on the right python}
\PYGZdl{}\PYG{+w}{ }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }venv\PYG{+w}{ }env\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} make the virtual environment}
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{source}\PYG{+w}{ }env/bin/activate\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} enable the new environment}
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }jupyterlab\PYG{+w}{ }numpy\PYG{+w}{ }scikit\PYGZhy{}learn\PYG{+w}{ }matplotlib\PYG{+w}{ }pandas
\PYGZdl{}\PYG{+w}{ }jupyter\PYGZhy{}lab\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} make sure it works}
\end{sphinxVerbatim}

\sphinxAtStartPar
When I tried this on one student machine it worked. Jupyterlab runs in a browser and you may have to click on a link that appears in your console to get it to run. (the link will contain \sphinxcode{\sphinxupquote{localhost}} or \sphinxcode{\sphinxupquote{127.0.0.1}})

\sphinxAtStartPar
The problem seems to be an incompatibility with the packages I defined in \sphinxcode{\sphinxupquote{requirements.txt}}. The Python Package Manager (\sphinxcode{\sphinxupquote{pip}}) tries to resolve dependencies in a consistent manner but does not always succed (i.e. it usually fails on big projects.) I was hopeful the environment I carefully curated would work on windows AET machines but it doesn’t. This short \sphinxcode{\sphinxupquote{pip install}} command installs what we need right now and will be fine until I can properly debug with my own machine.

\sphinxstepscope


\chapter{August 28}
\label{\detokenize{lessons/cw03:august-28}}\label{\detokenize{lessons/cw03::doc}}
\sphinxAtStartPar
Today in class
\begin{itemize}
\item {} 
\sphinxAtStartPar
5 minutes for computer bugfixing

\item {} 
\sphinxAtStartPar
Present findings for weather data

\item {} 
\sphinxAtStartPar
Upload HW to server
\begin{itemize}
\item {} 
\sphinxAtStartPar
wsl: \sphinxcode{\sphinxupquote{cd}} into the \sphinxcode{\sphinxupquote{ml}} directory where your jupyter notebook is located (download it if it’s online)
\begin{itemize}
\item {} 
\sphinxAtStartPar
wifi: AET\sphinxhyphen{}3142

\item {} 
\sphinxAtStartPar
use wsl \sphinxcode{\sphinxupquote{ftp}} and \sphinxcode{\sphinxupquote{ftp username@ubuntu}}

\item {} 
\sphinxAtStartPar
your username is \sphinxcode{\sphinxupquote{lllllllf}}, (first 7 letters of last name, then first initial, according to phoenix)

\item {} 
\sphinxAtStartPar
passwd is your student ID

\item {} 
\sphinxAtStartPar
to save the file: \sphinxcode{\sphinxupquote{put filename}} (tab completion should probably work here)

\item {} 
\sphinxAtStartPar
to check it’s there: \sphinxcode{\sphinxupquote{ls}}

\item {} 
\sphinxAtStartPar
to disconnect \sphinxcode{\sphinxupquote{ctrl\sphinxhyphen{}D}} or (I think) \sphinxcode{\sphinxupquote{exit}}

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Discuss Bayes’ Theorem, including Jupyter notebook and python concepts
\begin{itemize}
\item {} 
\sphinxAtStartPar
lists, arrays and comprehensions in python

\item {} 
\sphinxAtStartPar
for loops in python

\item {} 
\sphinxAtStartPar
add, delete cells in Jupyter

\item {} 
\sphinxAtStartPar
Markdown cells and syntax\textbackslash{}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Homework is complete the Bayes’ Theorem Jupyter notebook.

\sphinxstepscope


\part{Measures of Closeness}

\sphinxstepscope


\chapter{Bayes’ Theorem}
\label{\detokenize{lessons/Bayes_Theorem_Student:bayes-theorem}}\label{\detokenize{lessons/Bayes_Theorem_Student::doc}}
\sphinxAtStartPar
Bayes’ Theorem gives us a way to \sphinxstyleemphasis{invert} conditional probabilities. The formula comes from the definition of conditional probability
\begin{equation*}
\begin{split}P(A|B) = \dfrac{P(A \cap B)}{P(B)}\end{split}
\end{equation*}
\sphinxAtStartPar
this implies the following
\begin{equation*}
\begin{split}P(A \cap B) = P(A|B)P(B) = P(B|A)P(A)\end{split}
\end{equation*}
\sphinxAtStartPar
Solving for \(P(A|B)\) we get
\begin{equation*}
\begin{split}P(A|B) = \dfrac{P(B|A)P(A)}{P(B)}\end{split}
\end{equation*}
\sphinxAtStartPar
Though this is the final form, in practice you will need to compute \(P(B)\) using the following
\begin{equation*}
\begin{split}P(B) = P(B|A)P(A) + P(B|\overline{A})P(\overline{A})\end{split}
\end{equation*}
\sphinxAtStartPar
which says the probability of \(B\) is the sum of the probability of \(B\) given \(A\) and \(B\) given not \(A\). (\(A\) is either true or false so these are the only two options)


\section{Exercise 1: Plot a Venn Diagram}
\label{\detokenize{lessons/Bayes_Theorem_Student:exercise-1-plot-a-venn-diagram}}
\sphinxAtStartPar
Using matplotlib, draw a simple Venn diagram representing two sets \(A\), \(B\) with a non\sphinxhyphen{}null intersection.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Code here. Add cells as needed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Exercise 2: Compute Bayes’ Probabilities}
\label{\detokenize{lessons/Bayes_Theorem_Student:exercise-2-compute-bayes-probabilities}}
\sphinxAtStartPar
We want to replicate the computation carried out in class. If a doctor performs a test that has a given accuracy, for a disease with a given incidence rate, determine the probability that a randomly selected person with a positive test result has the disease. You are given \sphinxstyleemphasis{accuracy} and \sphinxstyleemphasis{incidence} as input, both in the range \((0,1]\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{n}{acc}\PYG{p}{,} \PYG{n}{inc}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} code here}
    \PYG{k}{return} \PYG{n}{bayes}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Check some results below. The first one comes from class

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.97}\PYG{p}{,}\PYG{l+m+mf}{0.001}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.97}\PYG{p}{,}\PYG{l+m+mf}{0.001}\PYG{p}{)}

\PYG{n+nn}{Cell In[2], line 3,} in \PYG{n+ni}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{n+nt}{(acc, inc)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{n}{acc}\PYG{p}{,} \PYG{n}{inc}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2}     \PYG{c+c1}{\PYGZsh{}\PYGZsh{} code here}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3}     \PYG{k}{return} \PYG{n}{bayes}

\PYG{n+ne}{NameError}: name \PYGZsq{}bayes\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.97}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.97}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{l+m+mf}{0.001}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{get\PYGZus{}bayes\PYGZus{}probability}\PYG{p}{(}\PYG{l+m+mf}{0.50}\PYG{p}{,}\PYG{l+m+mf}{0.001}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Exercise 3: Plot}
\label{\detokenize{lessons/Bayes_Theorem_Student:exercise-3-plot}}
\sphinxAtStartPar
You will create two plots in the section. For a fixed incidence rate, plot the bayes probability as the accuracy of the test ranges from 0 to 100\%.

\sphinxAtStartPar
Then, for a fixed accuracy, plot the bayes probability as the incidence rate increases.

\sphinxAtStartPar
\sphinxstylestrong{Note}, to avoid 1/0 errors you’ll probably want to \sphinxstyleemphasis{not} go all the way to 0 or 1.

\sphinxAtStartPar
State a conclusion about the results. What’s the correlation? What do you observe? What do you think about accuracy measures for tests now?

\sphinxAtStartPar
Hint: create two arrays \sphinxcode{\sphinxupquote{X,Y}} (python lists) of the same length containing the X values in one array and the Y values in another. List comprehensions are the best way to do this in python, though a for loop is fine too (append to an initially empty list)

\sphinxAtStartPar
then use \sphinxcode{\sphinxupquote{plt.plot(X,Y)}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} code here. add as needed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Exercise 4: Beautify plots}
\label{\detokenize{lessons/Bayes_Theorem_Student:exercise-4-beautify-plots}}
\sphinxAtStartPar
Now go back and beautify your plots. Add a title and a legend. Some axis labels. Maybe read about matplotlib styles and change up the colors. Try a different type of  plot. Just experiment some. Results below.

\sphinxstepscope


\chapter{Quick Jupyter Intro and Python Loops}
\label{\detokenize{lessons/jupyter-python-intro:quick-jupyter-intro-and-python-loops}}\label{\detokenize{lessons/jupyter-python-intro::doc}}
\sphinxAtStartPar
Jupyter notebook is arranged into cells. Cells can contain Input (computations/code), Output and Markdown (text). A cell can be \sphinxstyleemphasis{selected} or \sphinxstyleemphasis{active}. To \sphinxstyleemphasis{select} a cell, click to the left of it and it should highlight with a colored border. To activate a cell, click inside of it so the cursor is visible. To run a code cell, or render a text cell, type \sphinxcode{\sphinxupquote{shift\sphinxhyphen{}return}}.

\sphinxAtStartPar
When a cell is selected you can do cell operations by typing single letters such as
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}} add a cell above this one

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{B}} add a cell below this one

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X}} cut the cell to the clipboard

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C}} copy the cell to the clipboard

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{V}} paste the cell on the clipboard

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D}} delete the cell

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{M}} convert a cell to markdown style

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Y}} convert a markdown cell back to Input style

\end{itemize}

\sphinxAtStartPar
You can also drag a selected cell around the notebook with the mouse. You should also get familiar with the menu bar and toolbars. There are several useful operations hidden there. For example, \sphinxstyleemphasis{rerun all cells} is handy as is \sphinxstyleemphasis{Clear Outputs of all cells}


\section{Python Loops}
\label{\detokenize{lessons/jupyter-python-intro:python-loops}}
\sphinxAtStartPar
I’ll show some basic examples of how to do things in python. You may want to run these in Jupyter to verify.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Print the numbers 0\sphinxhyphen{}99 on separate lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Print the numbers 10\sphinxhyphen{}99 on separate lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Print the \sphinxstyleemphasis{even} numbers 10\sphinxhyphen{}19 on separate lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Print all characters in “hello computer”, all on one line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{the word}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Compute the largest Fibonacci number less than 1000 (note the use of parallel assignment)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1000}\PYG{p}{:}
		\PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{,}\PYG{n}{a}
\end{sphinxVerbatim}

\end{itemize}


\section{Python Lists}
\label{\detokenize{lessons/jupyter-python-intro:python-lists}}
\sphinxAtStartPar
Python’s regular list data type is not a true array, such as you would find in C or Java. An array is, properly, fixed length and single type. Python uses \sphinxstyleemphasis{lists} which are dynamic (auto\sphinxhyphen{}resizing) and can contain \sphinxstyleemphasis{any} type. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{l1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{l2} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bird}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.3}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cow}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{l3} \PYG{o}{=} \PYG{p}{[}\PYG{n}{l1}\PYG{p}{,}\PYG{n}{l2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l2}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l3}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.3}
\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
You see lists can even contain lists. Here are some familiar tropes in Python

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} a list of 10 zeros}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}  \PYG{c+c1}{\PYGZsh{} replace the zeros with the index}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{l}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} add more elements to l}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{l} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} another way to add}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This prints the integers from 0 to 29 inclusive.

\sphinxAtStartPar
Lists are very flexible and there are many operations that are easy to do such as sort, find, replace, merge, delete. If you want to perform a list operation, look it up in online and see if it is already a built\sphinxhyphen{}in operation


\section{Comprehensions}
\label{\detokenize{lessons/jupyter-python-intro:comprehensions}}
\sphinxAtStartPar
Comprehensions are beautiful and lovely ways to build lists quickly. I’ll just give a couple examples here

\sphinxAtStartPar
This code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{l}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
can be replaced with this comprehension

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is quite lovely, isn’t it. It reads like a math set definition
\begin{equation*}
\begin{split} L = \{i^2 \; | \;  0 \leq i < 10\}\end{split}
\end{equation*}
\sphinxAtStartPar
And make great tools for plotting, say

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{sin}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{100} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{628}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{Y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{628}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will plot one period of a sine curve.

\sphinxAtStartPar
In practice, numerical algorithms will use \sphinxcode{\sphinxupquote{numpy arrays}} instead of python lists because they are much much faster and work like traditional C arrays. But lists still come in extremely handy when you need to collect data and speed is not a priority.

\sphinxstepscope


\chapter{Linear Regression}
\label{\detokenize{lessons/Linear_regression_derivation:linear-regression}}\label{\detokenize{lessons/Linear_regression_derivation::doc}}
\sphinxAtStartPar
Given \(n\) points \(\left(x_{1}, y_{1}\right) \ldots\left(x_{n}, y_{n}\right)\)
and an assumed relation \(y=f(x)+\epsilon, \epsilon \sim N(\mu, \sigma)\)
we want to find a model \(\tilde{y_i}=a x_i+b\)
such that the residual squared error
\begin{equation*}
\begin{split}
\operatorname{RSS}(a, b)=\sum_{i=1}^n \left(\tilde{y}_{i}-y_{i}\right)^{2}
\end{split}
\end{equation*}
\sphinxAtStartPar
is minimized.

\sphinxAtStartPar
\(RSS\) is a function of the line parameters \(a\) and \(b\). To minimize
it we set both partial derivatives to zero. (This could technically
find a maximum – but it’s reasonably clear this function has no maximum value because the error can always be increased.)

\sphinxAtStartPar
Take partial derivatives
\begin{equation*}
\begin{split}
\begin{aligned}
\frac{\partial RSS}{\partial a} & =2 \sum\left(\tilde{y}_{c}-y_{i}\right) \frac{\partial}{\partial a}\left(\tilde{y}_{i}-y_{i}\right) \\
& =2 \sum\left(\tilde{y}_{i}-y_{i}\right)\left(x_{i}\right) \\
\frac{\partial R S S}{\partial b} & =2 \sum\left(\tilde{y}_{i}-y_{i}\right)\frac{\partial}{\partial b}\left(\tilde{y}_{i}-y_{i}\right) \\
& =2 \sum\left(\tilde{y}_{i}-y_{i}\right)(1)
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Since
\begin{equation*}
\begin{split}\frac{\partial}{\partial a} \tilde{y}_{i}=\frac{\partial}{\partial a}\left(a x_{i}+b\right)=x_{i}\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\frac{\partial}{\partial b} \tilde{y}_{c}=\frac{\partial}{\partial b}\left(a x_{c}+b\right)=1
\end{split}
\end{equation*}
\sphinxAtStartPar
And solve
\begin{equation*}
\begin{split}\left\{\begin{array}{l}\dfrac{\partial R S S}{\partial a}=0 \\[20pt] \dfrac{\partial R S S}{\partial b}=0\end{array} \Rightarrow\left\{\begin{array}{l}\left.\sum (\tilde{y}_{i}-y_{i}\right) x_{i}=0 \\[10pt] \sum\left(\tilde{y}_{i}-y_{i}\right)=0\end{array}\right.\right.\end{split}
\end{equation*}
\sphinxAtStartPar
Since \(\tilde{y}_{i} = ax_i+b\)
\$\(\sum\left(a x_{i}+b-y_{i}\right) x_{i}=0 \Rightarrow a \sum x_{i}^{2}+b \sum x_{i}=\sum y_{i} x_{j}\)\(
and
\)\(\sum\left(a x_{i}+b-{y}_{i}\right)=0 \Rightarrow a \sum x_{i}+b \sum 1=\sum y_{i}\)\$

\sphinxAtStartPar
by Cramer’s rule
\begin{equation*}
\begin{split}
\begin{aligned}
a & =\left|\begin{array}{ll}
\sum x_{i} y_{i} & \sum x_{i} \\
\sum y_{i} & n
\end{array}\right| /\left|\begin{array}{ll}
\sum x_{i}^{2} & \sum x_{i} \\
\sum x_{i} & n
\end{array}\right| \\
b & =\left|\begin{array}{ll}
\sum x_{i}^{2} & \sum x_{i} y_{i} \\
\sum x_{i} & \sum y_{i}
\end{array}\right| /\left|\begin{array}{ll}
\sum x_{i}^{2} & \sum x_{i} \\
\sum x_{i} & n
\end{array}\right|
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
since \(\sum_{i=1}^{n} 1=n\)

\sphinxAtStartPar
Taking determinants,
\$\(a=\frac{n \sum x_{i} y_{i}-\left(\sum x_{i}\right)\left(\sum y_{i}\right)}{n \sum x_{i}^{2}-\left(\sum x_{i}\right)^{2}}\)\$
\begin{equation*}
\begin{split}
b=\frac{\sum y_{i} \sum x_{i}^{2}-\sum x_{i} \sum x_{i} y_{i}}{n \sum x_{i}^{2}-\left(\sum x_{i}\right)^{2}}
\end{split}
\end{equation*}

\section{Interpretation as a ratio of variances}
\label{\detokenize{lessons/Linear_regression_derivation:interpretation-as-a-ratio-of-variances}}
\sphinxAtStartPar
Students of statistics may appreciate the following manipulations

\sphinxAtStartPar
\sphinxstyleemphasis{Definition} of covariance
\$\(E(x y)-E(x) E(y)=\operatorname{Cov}(x, y)\)\$

\sphinxAtStartPar
\sphinxstyleemphasis{Definition} of variance
\begin{equation*}
\begin{split}\operatorname{Var}(x)=E\left[(x-\mu)^{2}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstyleemphasis{Lemma}
\begin{equation*}
\begin{split}
\begin{aligned}
\operatorname{Var}(x)&=E\left[(x-\mu)^{2}\right] \\
&=E\left(x^{2}\right)-2 \mu E[x]+E[\mu]^{2} \\
&=E\left[x^{2}\right]-2 E[x]^{2}+\mu^{2} \\
&=E\left[x^{2}\right]-E[x]^{2}
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Manipulating the denominator of the equation for \(a\) on the previous page,
\$\(
\begin{aligned}
n \sum x_{i}^{2}-\left(\sum x_{i}\right)^{2} & =n^{2}\left(\frac{1}{n} \sum x_{i}^{2}-\left(\frac{\sum x_{i}}{n}\right)^{2}\right) \\
& =n^{2}\left(E\left[x^{2}\right]-E[x]^{2}\right) \\
& =n^{2} \operatorname{Var}(x)
\end{aligned}
\)\$

\sphinxAtStartPar
And the numerator
\$\(
\begin{aligned}
n \sum x_{i} y_{i}-\sum x_{i} \sum y_{i} \\
& =n^{2}\left(\frac{1}{n} \sum x_{i} y_{i}-\frac{1}{n} \sum x_{i} \cdot\frac1n \sum y_{i}\right) \\
& =n^{2}\left(E\left[x y\right]-E[x] E[y]\right) \\
& =n^{2}\left(E[x y]-\mu_{y} \mu_{y}\right) \\
& = n^2 \operatorname{Cov}(x,y)
\end{aligned}
\)\$

\sphinxAtStartPar
so
\begin{equation*}
\begin{split}a=\frac{E[x y]-\mu_{x} \mu_{y}}{E[x]-\mu_{x}^{2}}=\frac{\operatorname{Cov}(x, y)}{\operatorname{Vav}(x)}\end{split}
\end{equation*}
\sphinxstepscope


\chapter{Linear Least Squares}
\label{\detokenize{lessons/least-squares-01:linear-least-squares}}\label{\detokenize{lessons/least-squares-01::doc}}
\sphinxAtStartPar
In class we derived the formula for linear least squares of one variable. In this notebook you will learn a bit of the numerical library numpy, use numpy to compute linear regression, and then compute it yourself using formulas from class

\sphinxAtStartPar
Begin by running the cell below. Then go back and carefully read through all the code. There is a lot of new stuff here. Note how to create numpy arrays/matrices and how to compute a linear least squares regression.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Step 1: Prepare your data}
\PYG{c+c1}{\PYGZsh{} x: Independent variable (input)}
\PYG{c+c1}{\PYGZsh{} y: Dependent variable (output)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 2: Perform linear regression using the least squares method}

\PYG{c+c1}{\PYGZsh{} Add a column of ones to the input data for the intercept (bias term)}
\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

\PYG{c+c1}{\PYGZsh{} Calculate the slope (m) and intercept (b)}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{lstsq}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{rcond}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Slope (a): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Intercept (b): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 3: Predict y values using the regression line}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{x} \PYG{o}{+} \PYG{n}{b}

\PYG{c+c1}{\PYGZsh{} Optional: Plot the data and the regression line}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data points}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Regression line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Slope (a): 0.6000
Intercept (b): 2.2000
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{d2cf2dbde1375c6ebeb5e8e563efd00bee02dbc8b157f0a650ab929e45826852}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{An aside about numpy matrices}
\label{\detokenize{lessons/least-squares-01:an-aside-about-numpy-matrices}}
\sphinxAtStartPar
What happened to x? Here’s the original \(x\), which is an array

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1, 2, 3, 4, 5])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We add a row of 1s after it and take the transpose to get the input matrix \(X\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 1.],
       [2., 1.],
       [3., 1.],
       [4., 1.],
       [5., 1.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Breaking this down into pieces, first let’s make a python list that contains \(x\) and an array of ones

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[array([1, 2, 3, 4, 5]), array([1., 1., 1., 1., 1.])]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now let’s use numpy to make a vertical stack. The first element in the list becomes the first row

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 2., 3., 4., 5.],
       [1., 1., 1., 1., 1.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And now take the transpose

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 1.],
       [2., 1.],
       [3., 1.],
       [4., 1.],
       [5., 1.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Practice with matrices}
\label{\detokenize{lessons/least-squares-01:practice-with-matrices}}
\sphinxAtStartPar
Make a numpy matrix that is a row of 5 zeros followed by a row of 5 ones, then 5 zeros, then 5 ones again. Use built in functions and \sphinxcode{\sphinxupquote{vstack}} (don’t just type a bunch of 0 and 1 – can you guess the name of a function that makes an array of zeros?)

\sphinxAtStartPar
Now make a similar matrix that is a row of all 1s followed by all 2s in the second row, then 3s then 4s. Again use built in function \sphinxcode{\sphinxupquote{np.ones}}. Name this matrix \sphinxcode{\sphinxupquote{M}}. Hint: \([2,2,2,2,2] = 2\cdot[1,1,1,1,1]\)

\sphinxAtStartPar
compute M times M transpose and M transpose times M (\(MM^T\) and \(M^TM\)). In \sphinxcode{\sphinxupquote{numpy}} \(AB\) can be computed with \sphinxcode{\sphinxupquote{A @ B}} for matrices \sphinxcode{\sphinxupquote{A}} and \sphinxcode{\sphinxupquote{B}}

\sphinxAtStartPar
A matrix \(M\) is \sphinxstyleemphasis{symmetric} if \(M = M^T\). This also implies \(M_{ij} = M_{ji}\) for all indices \((i,j)\). Write a python function \sphinxcode{\sphinxupquote{is\_symmetric(M)}} which returns \sphinxcode{\sphinxupquote{true}} if and only if \(M\) is symmetric

\sphinxAtStartPar
Test your function. Make a 5 by 5 random integer matrix (see \sphinxcode{\sphinxupquote{np.random.randint}}) called \(M\). It is a fact that \(MM^T\) is always symmetric. Check that your function return \sphinxcode{\sphinxupquote{true}} for \(MM^T\) and \sphinxcode{\sphinxupquote{false}} for \(M\). Repeat this trial 100 times and verify all 100 are correct.


\section{Linear Least Squares Regression}
\label{\detokenize{lessons/least-squares-01:linear-least-squares-regression}}
\sphinxAtStartPar
You can create a vector of normally distributed samples with mean \(\mu\) and standard deviation \(\sigma\) by using the numpy function \sphinxcode{\sphinxupquote{np.random.normal(mu, sigma, n)}}. Try creating a vector with 10 random samples, with a mean of 100 and a standard deviation of 5.

\sphinxAtStartPar
Now create some data for linear regression. Make a vector \(x\) of ints over the range \([0,9]\) and let \(y\) be a linear function of \(x\), \(y = 3x+2+\epsilon(x)\) where \(\epsilon(x)\) is a random Gaussian noise function \(\epsilon(x) \sim N(0,1)\). Make a scatter plot of \(y\) vs. \(x\) and label it

\sphinxAtStartPar
Compute the correct linear regression coefficients using numpy as above. Check they are resonable.

\sphinxAtStartPar
Now compute the regression coefficients using the formulas from class. Begin by defining some very helpful variables: \sphinxcode{\sphinxupquote{Sx, Sy}} will be \(\sum_i {x_i}\) and \(\sum_i {y_i}\) respectively. Next \sphinxcode{\sphinxupquote{Sxx}} and \sphinxcode{\sphinxupquote{Syy}} are the sum of squares: \(\sum_i {x_i}^2\) and \(\sum_i {y_i}^2\). Finally the inner product \sphinxcode{\sphinxupquote{Sxy}} = \(\sum_i x_iy_i\). The quickest way to do this involves using comprehensions and the \sphinxcode{\sphinxupquote{sum}} function, but you can use loops for now if you need to.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Print your results}
\PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxx}\PYG{p}{,} \PYG{n}{Syy}\PYG{p}{,} \PYG{n}{Sxy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{2}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} Print your results}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxx}\PYG{p}{,} \PYG{n}{Syy}\PYG{p}{,} \PYG{n}{Sxy}

\PYG{n+ne}{NameError}: name \PYGZsq{}Sx\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Finally determine \(a,b\) as in class. Display the absolute errors between your calculations and the ones numpy returned. (They should be close to machine precision, which is \(10^{-15}\) give or take.


\section{Least squares function}
\label{\detokenize{lessons/least-squares-01:least-squares-function}}
\sphinxAtStartPar
Did you know python can return two values? Here’s an example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{two\PYGZus{}numbers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{k}{return} \PYG{n}{a}\PYG{p}{,}\PYG{n}{b}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{,} \PYG{n}{B} \PYG{o}{=} \PYG{n}{two\PYGZus{}numbers}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Write a function \sphinxcode{\sphinxupquote{linear\_least\_squares(x,y)}} which takes input vectors x,y and returns a,b as above. (

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{linear\PYGZus{}least\PYGZus{}squares}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Application}
\label{\detokenize{lessons/least-squares-01:application}}
\sphinxAtStartPar
Now, using \(a=5, b =-15\), run linear least squares 100 times on 100 vector pairs \((x,y)\), where each of the 100 \(x\) are the same but the \(y=ax+b+\epsilon\) each have different amounts of Gaussian noise.  Plot the resulting best fit lines all on the same graph.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{np.arange}} to make your input vector \(x\) cover the domain \([-5,5]\) with a step\sphinxhyphen{}size of 0.01

\item {} 
\sphinxAtStartPar
Create arrays to store all the computed a and b values (you’ll use this later)

\item {} 
\sphinxAtStartPar
If you call \sphinxcode{\sphinxupquote{plt.plot()}} in a loop, it will keep adding to the same plot

\item {} 
\sphinxAtStartPar
Give your plot a title!

\end{itemize}

\sphinxAtStartPar
Determine the average of the \(a\)s and \(b\)s returned above. Compare these to the true \(a,b\). Explain your result.(There is an \sphinxcode{\sphinxupquote{np.mean}} function)

\sphinxAtStartPar
Make two histogram plots of the calculated \(a\) and \(b\) values \sphinxcode{\sphinxupquote{plt.hist}} works nicely and adding a semicolon suppressed the nasty text output (you’ll see)

\sphinxstepscope


\chapter{Correlation Coefficient}
\label{\detokenize{lessons/Correlation_Coefficient:correlation-coefficient}}\label{\detokenize{lessons/Correlation_Coefficient::doc}}
\sphinxAtStartPar
We assume, as usual, a ground truth model \(y = f(x) + \epsilon\) where \(f\) is usually unknown, a (possibly random) sample of points \((x_1, y_1), \cdots, (x_n, y_n)\) and a linear model \(\tilde{y} = ax + b\). In this setting we usually need to know \sphinxstyleemphasis{how good} the linear model is – how well does if capture the ground truth \(f(x)\)?

\sphinxAtStartPar
One obvious measure is the sum of squared errors, which we minimized last class to derive the linear regression equations.
\begin{equation*}
\begin{split}SSE = \sum_{i=1}^n (\tilde{y}_i - y_i)^2\end{split}
\end{equation*}
\sphinxAtStartPar
While this literally captures the error in the model on each point, it is hard to interpret, it scales with the number of points, and is in different units from the given data. We can normalize it to the mean sum of squared errors:
\begin{equation*}
\begin{split}MSE = \dfrac{1}{n}\sum_{i=1}^n (\tilde{y}_i - y_i)^2\end{split}
\end{equation*}
\sphinxAtStartPar
which at least doesn’t scale with the number of points but is in different units. Thus by taking a radical
\begin{equation*}
\begin{split}RMSE = \sqrt{\dfrac{1}{n}\sum_{i=1}^n (\tilde{y}_i - y_i)^2}\end{split}
\end{equation*}
\sphinxAtStartPar
we get the root mean sum of squared errors. This at least scales with the magnitude of the \(y\) values, so you can interpret it somewhat. It is also similar
to a standard deviation, which is familiar to many people. (Note some texts would divide by \(n-2\) instead of \(n\) to create a truly unbiased
estimator for the standard deviation, but this simpler version aggrees with other data science presentations, including kaggle.)


\section{Pearson’s Correlation Coefficient}
\label{\detokenize{lessons/Correlation_Coefficient:pearson-s-correlation-coefficient}}
\sphinxAtStartPar
While variants of SSE have their place, one cannot escape the use of \(r\), the Pearson’s correlation coefficient. Students learn in algebra classes
that a linear regression coefficient \(r=1\) is a perfect positive correlation and \(r=-1\) is a perfect negative correlation and \(r=0.5\) is a weak
correlation, for example. We will take a more precise approach.

\sphinxAtStartPar
One formular for \(r\) is
\begin{equation*}
\begin{split}r^2 = \dfrac{SS_{reg}}{SS_{tot}} = \dfrac{\sum_i(\tilde{y}_i - \overline{y})^2} {\sum_i(y_i - \overline{y})^2}\end{split}
\end{equation*}
\sphinxAtStartPar
Let’s unpack this. \(SS_{reg}\) is the sum of squared\sphinxhyphen{}error due to regression and \(SS_{tot}\) is the sum of squared\sphinxhyphen{}error total (due to the original data).
Here \(\overline{y} = \frac1n\sum_i y_i\) is the mean of the observed \(y_i\) values. \(SS_{tot}\), then, is the variance of the observed \(y_i\) values – it is the
sum of the squared deviations of the observations from their mean.

\sphinxAtStartPar
\(SS_{reg}\), on the other hand, is the variance of the predicted \(\tilde{y}_i\) values, relative to the same observed mean.

\sphinxAtStartPar
The ratio of the two is the ratio of the “explained variance” to the “total variance.” There is always variance in the original dataset. If our linear
model very closely fits the data, then it will explain most of that original variance. That would correspond to a high \(r^2\) value. On the other hand
a low \(r^2\) indicates that there is variance in the data that is not capture by the linear model. Something else is happening to create this
data shape.

\sphinxAtStartPar
It can be helpful to think of \(r^2\) as the percent of “explained variance”. You’ll notice this formula is for \(r^2\), not \(r\). Obviously both are \(<1\) but
they are not identical. We may see more details of the various ways to interpret \(r\) vs \(r^2\) but honestly for most cases this explanation
is quite good enough and better than what most people understand!


\section{r=0}
\label{\detokenize{lessons/Correlation_Coefficient:r-0}}
\sphinxAtStartPar
You may have been taught that \(r=0\) implies no correlation between \(x\) and \(y\) pairs. This is often indicated in math books with an
amorphous cloud of points, wandering lonely across the page, enigmatic and unknowable. Actually a number of highly correlated
datasets can claim to possess \(r=0\) values as this helpful chart shows%
\begin{footnote}[1]\sphinxAtStartFootnote
By DenisBoigelot, original uploader was Imagecreator \sphinxhyphen{} Own work, original uploader was Imagecreator, CC0, \sphinxurl{https://commons.wikimedia.org/w/index.php?curid=15165296}
%
\end{footnote}

\sphinxAtStartPar
\sphinxincludegraphics{{correlation_examples}.png}

\sphinxAtStartPar
To be correct, \(r=0\) implies no \sphinxstylestrong{linear} correlation between \(x\) and \(y\). If it so happens that every predicted \(\tilde{y}_i\) value is identical to the
mean \(\overline{y}\), then \(r^2=0\). Datasets with perfect vertical symmetry can have this property.


\bigskip\hrule\bigskip


\sphinxstepscope


\part{Linear Algebra in Python}

\sphinxstepscope


\chapter{Linear Algebra and Python Lists}
\label{\detokenize{lessons/Matrices-student:linear-algebra-and-python-lists}}\label{\detokenize{lessons/Matrices-student::doc}}
\sphinxAtStartPar
This notebook will review some important concepts in linear algebra while helping you practice working with lists and nested lists in Python. You will provide code cells as needed to complete the sections below. Testing code is provided for you to help check that your methods perform as expected.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Dot product of two vectors}
\label{\detokenize{lessons/Matrices-student:dot-product-of-two-vectors}}
\sphinxAtStartPar
\(\vec{a} \cdot \vec{b} = \sum_i a_ib_i\) is the dot product (or inner product) between \(\vec{a}\) and \(\vec{b}\). Write a python function \sphinxcode{\sphinxupquote{dot\_product(a,b)}} that returns a dot product of two input python lists (do not use numpy arrays yet). If the input types do not match, raise a ValueError.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The following cells will check your dot\_product method for correctness and for catching errors.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{20}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k}{assert}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{20}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}dot\PYGZus{}product\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Size mismatched caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Cross Product of two vectors}
\label{\detokenize{lessons/Matrices-student:cross-product-of-two-vectors}}
\sphinxAtStartPar
Given two real 3\sphinxhyphen{}vectors \sphinxstylestrong{a} and \sphinxstylestrong{b}:
\begin{equation*}
\begin{split}
\mathbf{A} = \begin{pmatrix} a_1 \\ a_2 \\ a_3 \end{pmatrix}, \quad
\mathbf{B} = \begin{pmatrix} b_1 \\ b_2 \\ b_3 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
The cross product of \sphinxstylestrong{a} and \sphinxstylestrong{b} is a new vector \sphinxstylestrong{C} defined as:
\begin{equation*}
\begin{split}
\mathbf{C} = \mathbf{A} \times \mathbf{B} = \begin{pmatrix}
a_2 b_3 - a_3 b_2 \\
a_3 b_1 - a_1 b_3 \\
a_1 b_2 - a_2 b_1
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
This resulting vector \sphinxstylestrong{C} is orthogonal (perpendicular) to both \sphinxstylestrong{a} and \sphinxstylestrong{b}, and its magnitude is equal to the area of the parallelogram formed by \sphinxstylestrong{a} and \sphinxstylestrong{b}.

\sphinxAtStartPar
The direction of \sphinxstylestrong{C} is determined by the right\sphinxhyphen{}hand rule.

\sphinxAtStartPar
The cross product of \sphinxstylestrong{a} and \sphinxstylestrong{b} can be expressed as the determinant of a 3x3 matrix:
\begin{equation*}
\begin{split}
\mathbf{a} \times \mathbf{b} = \begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
a_1 & a_2 & a_3 \\
b_1 & b_2 & b_3
\end{vmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Where \sphinxstylestrong{i}, \sphinxstylestrong{j}, and \sphinxstylestrong{k} are the unit vectors along the x, y, and z axes, respectively.

\sphinxAtStartPar
To compute the determinant, expand along the first row (using cofactor expansion):
\begin{equation*}
\begin{split}
\mathbf{a} \times \mathbf{b} =
\mathbf{i} \begin{vmatrix} a_2 & a_3 \\ b_2 & b_3 \end{vmatrix} -
\mathbf{j} \begin{vmatrix} a_1 & a_3 \\ b_1 & b_3 \end{vmatrix} +
\mathbf{k} \begin{vmatrix} a_1 & a_2 \\ b_1 & b_2 \end{vmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Each of these 2x2 determinants is computed as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
For the \sphinxstylestrong{i} component:
\$\(
\mathbf{i} \cdot \left( a_2 b_3 - a_3 b_2 \right)
\)\$

\item {} 
\sphinxAtStartPar
For the \sphinxstylestrong{j} component (note the negative sign):
\$\( 
-\mathbf{j} \cdot \left( a_1 b_3 - a_3 b_1 \right)
\)\$

\item {} 
\sphinxAtStartPar
For the \sphinxstylestrong{k} component:
\$\(
\mathbf{k} \cdot \left( a_1 b_2 - a_2 b_1 \right)
\)\$

\end{itemize}

\sphinxAtStartPar
Thus, the cross product is:
\begin{equation*}
\begin{split}
\mathbf{a} \times \mathbf{b} = \left( a_2 b_3 - a_3 b_2 \right) \mathbf{i} - \left( a_1 b_3 - a_3 b_1 \right) \mathbf{j} + \left( a_1 b_2 - a_2 b_1 \right) \mathbf{k}
\end{split}
\end{equation*}
\sphinxAtStartPar
Or, written in vector form:
\begin{equation*}
\begin{split}
\mathbf{a} \times \mathbf{b} = \begin{pmatrix}
a_2 b_3 - a_3 b_2 \\
a_3 b_1 - a_1 b_3 \\
a_1 b_2 - a_2 b_1
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
This is the cross product of the vectors \sphinxstylestrong{a} and \sphinxstylestrong{b}, derived from the determinant of a 3x3 matrix.

\sphinxAtStartPar
Write a python method which returns the cross product of 2 3D vectors, and throws an error in case of invalid input

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
These cells will check your method

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{cross\PYGZus{}product}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{cross\PYGZus{}product}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Size mismatched caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Vector magnitude}
\label{\detokenize{lessons/Matrices-student:vector-magnitude}}
\sphinxAtStartPar
The magnitude, or length, of a vector is defined as

\sphinxAtStartPar
\(||\vec{x} || = \sqrt{\vec{x} \cdot \vec{x}} = \sqrt{x_0^2 + x_1^2 + \cdots + x_{n-1}^2}\). Notice the exponent on each element is \(2\) and the radical exponent is \(\frac12\). This is an \(L_2\) norm. If we compute the value \(\sqrt[3]{x_0^3 + x_1^3 + \cdots + x_{n-1}^3}\), this is an \(L_3\) norm. The sum of absolute values \(|x_1| + |x_2| + \cdots + |x_n|\) is called the \(L_1\) norm. All of these are \(p\)\sphinxhyphen{}norms, with the \(p=2\) being the most familiar, and the \(p=1\) norm being useful in several settings.

\sphinxAtStartPar
Write a python method \sphinxcode{\sphinxupquote{norm(a)}} which returns the 2\sphinxhyphen{}norm (length) of a vector, by calling \sphinxcode{\sphinxupquote{dot\_product}}. Then write \sphinxcode{\sphinxupquote{p\_norm(a,p)}} which evaluates the \(p\)\sphinxhyphen{}norm for any integer \(p \geq 1\) and throws an error if needed.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
This cell will check your method

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{)}\PYG{o}{==}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5000}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
These cells will check your \sphinxcode{\sphinxupquote{p\_norm}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{p\PYGZus{}norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{p\PYGZus{}norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{p\PYGZus{}norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{p\PYGZus{}norm}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Invalid p caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Angle between vectors}
\label{\detokenize{lessons/Matrices-student:angle-between-vectors}}
\sphinxAtStartPar
A very important result from linear algebra used in machine learning relates the angle between two vectors. You will derive this yourself. Given \sphinxstylestrong{a} and \sphinxstylestrong{b}, you can form a triangle where the vectors share the same tail. The vector forming the third side is the vector \sphinxstylestrong{a\sphinxhyphen{}b}. Find the length of this third side in terms of \sphinxstylestrong{a} and \sphinxstylestrong{b}. Hint: use the law of cosines. Hint: dot product distributes like ‘times’

\sphinxAtStartPar
Using your result write a function \sphinxcode{\sphinxupquote{angle\_between}} that returns the smallest angle between two vectors \sphinxstylestrong{a} and \sphinxstylestrong{b}. Make sure your result is in the range \([0,\pi]\)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.300523983021863}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Size mismatch caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Matrix Operations}
\label{\detokenize{lessons/Matrices-student:matrix-operations}}
\sphinxAtStartPar
Matrix addition and subtraction are componentwise and require matrices of the same size: \(m_{ij} = a_{ij} + b_{ij}\) or  \(m_{ij} = a_{ij} - b_{ij}\)

\sphinxAtStartPar
Matrix multiplication involves one entire row and one entire column of each matrix to determine an entry in the product. It can be written as
\begin{equation*}
\begin{split}m_{ij} = a_{ik}b^{kj}\end{split}
\end{equation*}
\sphinxAtStartPar
Where we are using \sphinxstyleemphasis{Einstein notation}. Each repeated index (here \(k\)) is an index of summation. Thus
\begin{equation*}
\begin{split}a_{ik}b^{kj} = \sum_{k=1}^m a_{ik}b_{kj}\end{split}
\end{equation*}
\sphinxAtStartPar
Matrix multiplication requires an \((m_1 \times n_1)\) matrix multiplied on the right by an \((m_2 \times n_2)\) matrix where \(n_1 = m_2\). The result is an \((m_1 \times n_2)\) matrix.

\sphinxAtStartPar
Write three methods: \sphinxcode{\sphinxupquote{mat\_add}}, \sphinxcode{\sphinxupquote{mat\_sub}}, \sphinxcode{\sphinxupquote{mat\_mul}}. You should throw an error
if dimensions do not match. You should store all matrices as 2D lists in python, i.e. lists of lists. The \(i,j\) element is referenced by \sphinxcode{\sphinxupquote{M{[}i{]}{[}j{]}}}, both starting at 0.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Size mismatch caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{A}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{B}\PYG{p}{)}

\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{A}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{B}\PYG{p}{)}

\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{A}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{92}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{37}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{C} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}

\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{==}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{46}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{18}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{mat\PYGZus{}add}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{mat\PYGZus{}mul}\PYG{p}{(}\PYG{n}{mat\PYGZus{}transpose}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shouldn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t get here}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Matrix incompatibility caught}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Introduction to Matrices in NumPy}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:introduction-to-matrices-in-numpy}}\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy::doc}}
\sphinxAtStartPar
Matrices are a fundamental data structure in scientific computing, and \sphinxcode{\sphinxupquote{numpy}} provides powerful tools for creating and manipulating matrices. This guide will introduce the basics of working with matrices in \sphinxcode{\sphinxupquote{numpy}} by covering the following topics:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Creating Matrices}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Accessing Elements}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basic Matrix Operations}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Extracting Rows and Columns}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Row and Column Operations}

\end{enumerate}

\sphinxAtStartPar
You should read the guide carefully and run the code cells. Feel free to edit individual cells for experimentation.

\sphinxAtStartPar
(This guide was created by ChatGPT and edited by Dr. White)


\section{1. Creating Matrices}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:creating-matrices}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{numpy}}, matrices are created as 2D arrays. Here are several ways to create them:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{a. Creating a Matrix from a List of Lists}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:a-creating-a-matrix-from-a-list-of-lists}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a 3x3 matrix of ints}
\PYG{n}{matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} 
                   \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} 
                   \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a 3x3 matrix with 64\PYGZhy{}bit float data types}
\PYG{n}{matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} 
                   \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} 
                   \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{n}{matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 2., 3.],
       [4., 5., 6.],
       [7., 8., 9.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{b. Creating Matrices with Built\sphinxhyphen{}in Functions}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:b-creating-matrices-with-built-in-functions}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a 3x3 matrix of zeros}
\PYG{n}{zeros\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a 3x3 matrix of ones}
\PYG{n}{ones\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a 3x3 identity matrix}
\PYG{n}{identity\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a 3x3 matrix with random values}
\PYG{n}{random\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{zeros\PYGZus{}matrix}\PYG{p}{,} \PYG{n}{ones\PYGZus{}matrix}\PYG{p}{,} \PYG{n}{identity\PYGZus{}matrix}\PYG{p}{,} \PYG{n}{random\PYGZus{}matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[0., 0., 0.],
        [0., 0., 0.],
        [0., 0., 0.]]),
 array([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]),
 array([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]),
 array([[0.18434837, 0.58114038, 0.26121578],
        [0.67994115, 0.74174803, 0.8308242 ],
        [0.1445397 , 0.07585411, 0.81144162]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{2. Accessing Elements}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:accessing-elements}}
\sphinxAtStartPar
You can access elements, rows, or columns of a matrix using indexing and slicing:


\subsection{a. Accessing Individual Elements}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:a-accessing-individual-elements}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Access element at row 1, column 2 (remember, indexing starts from 0)}
\PYG{n}{element} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{element}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.float64(6.0)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{b. Accessing Rows and Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:b-accessing-rows-and-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Access the second row (index 1)}
\PYG{n}{second\PYGZus{}row} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Access the third column (index 2)}
\PYG{n}{third\PYGZus{}column} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{n}{second\PYGZus{}row}\PYG{p}{,} \PYG{n}{third\PYGZus{}column}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([4., 5., 6.]), array([3., 6., 9.]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{c. Modifying parts of a matrix}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:c-modifying-parts-of-a-matrix}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{matrix\PYGZus{}2} \PYG{o}{=} \PYG{n}{matrix}
\PYG{n}{matrix\PYGZus{}2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]]),
 array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{d. Matrix references}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:d-matrix-references}}
\sphinxAtStartPar
Notice the above matrix\_2 copied a reference to matrix so any change to one changed both. To duplicate a matrix you need to create a new matrix. Notice the two are different in the following cell.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{matrix\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
\PYG{n}{matrix\PYGZus{}2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{/} \PYG{l+m+mi}{100}
\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]]),
 array([[1.  , 2.  , 3.  ],
        [0.05, 0.06, 0.07],
        [7.  , 8.  , 9.  ]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{3. Basic Matrix Operations}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:basic-matrix-operations}}
\sphinxAtStartPar
NumPy allows you to perform various matrix operations easily.


\subsection{a. Matrix Addition and Subtraction}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:a-matrix-addition-and-subtraction}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Add two matrices}
\PYG{n}{result\PYGZus{}add} \PYG{o}{=} \PYG{n}{matrix} \PYG{o}{+} \PYG{n}{identity\PYGZus{}matrix}

\PYG{c+c1}{\PYGZsh{} Subtract two matrices}
\PYG{n}{result\PYGZus{}subtract} \PYG{o}{=} \PYG{n}{matrix} \PYG{o}{\PYGZhy{}} \PYG{n}{identity\PYGZus{}matrix}

\PYG{n}{result\PYGZus{}add}\PYG{p}{,} \PYG{n}{result\PYGZus{}subtract}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[ 2.,  2.,  3.],
        [ 5.,  7.,  7.],
        [ 7.,  8., 10.]]),
 array([[0., 2., 3.],
        [5., 5., 7.],
        [7., 8., 8.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{b. Matrix Multiplication}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:b-matrix-multiplication}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Element\PYGZhy{}wise multiplication}
\PYG{n}{element\PYGZus{}wise\PYGZus{}product} \PYG{o}{=} \PYG{n}{matrix} \PYG{o}{*} \PYG{n}{matrix}

\PYG{c+c1}{\PYGZsh{} Matrix multiplication, two ways}
\PYG{n}{matrix\PYGZus{}product} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{identity\PYGZus{}matrix}\PYG{p}{)}
\PYG{n}{mp} \PYG{o}{=} \PYG{n}{matrix} \PYG{o}{@} \PYG{n}{identity\PYGZus{}matrix}

\PYG{n}{element\PYGZus{}wise\PYGZus{}product}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}product}\PYG{p}{,} \PYG{n}{mp}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[ 1.,  4.,  9.],
        [25., 36., 49.],
        [49., 64., 81.]]),
 array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]]),
 array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{c. Transpose of a Matrix}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:c-transpose-of-a-matrix}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Transpose the matrix}
\PYG{n}{transpose\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{matrix}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{transpose\PYGZus{}matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 5., 7.],
       [2., 6., 8.],
       [3., 7., 9.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{d. Determinant and Inverse}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:d-determinant-and-inverse}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the determinant}
\PYG{n}{determinant} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate the inverse (if the matrix is invertible)}
\PYG{n}{inverse\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)} \PYG{k}{if} \PYG{n}{determinant} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{k}{else} \PYG{k+kc}{None}

\PYG{n}{determinant}\PYG{p}{,} \PYG{n}{inverse\PYGZus{}matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(np.float64(\PYGZhy{}5.329070518200744e\PYGZhy{}15),
 array([[ 3.75299969e+14, \PYGZhy{}1.12589991e+15,  7.50599938e+14],
        [\PYGZhy{}7.50599938e+14,  2.25179981e+15, \PYGZhy{}1.50119988e+15],
        [ 3.75299969e+14, \PYGZhy{}1.12589991e+15,  7.50599938e+14]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{4. Extracting Rows and Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:extracting-rows-and-columns}}

\subsection{a. Extracting Rows}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:a-extracting-rows}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Extract the first row (index 0)}
\PYG{n}{first\PYGZus{}row} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
\PYG{n}{first\PYGZus{}row}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1., 2., 3.])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{b. Extracting Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:b-extracting-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Extract the second column (index 1)}
\PYG{n}{second\PYGZus{}column} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Extract the last column (index \PYGZhy{}1)}
\PYG{n}{last\PYGZus{}column}  \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{second\PYGZus{}column}\PYG{p}{,} \PYG{n}{last\PYGZus{}column}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([2., 6., 8.]), array([3., 7., 9.]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{c. Extracting Submatrices}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:c-extracting-submatrices}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Extract a 2x2 submatrix from the top\PYGZhy{}left corner}
\PYG{n}{submatrix} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{submatrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 2.],
       [5., 6.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{5. Row and Column Operations}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:row-and-column-operations}}

\subsection{a. Sum, Mean, and Other Operations on Rows/Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:a-sum-mean-and-other-operations-on-rows-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Sum of each row}
\PYG{n}{row\PYGZus{}sum} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Mean of each column}
\PYG{n}{column\PYGZus{}mean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{row\PYGZus{}sum}\PYG{p}{,} \PYG{n}{column\PYGZus{}mean}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([ 6., 18., 24.]), array([4.33333333, 5.33333333, 6.33333333]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{b. Adding Rows/Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:b-adding-rows-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Add a row (shape should match)}
\PYG{n}{new\PYGZus{}matrix\PYGZus{}row} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{matrix}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add a column (shape should match)}
\PYG{n}{new\PYGZus{}matrix\PYGZus{}column} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{matrix}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{new\PYGZus{}matrix\PYGZus{}row}\PYG{p}{,} \PYG{n}{new\PYGZus{}matrix\PYGZus{}column}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[ 1.,  2.,  3.],
        [ 5.,  6.,  7.],
        [ 7.,  8.,  9.],
        [10., 11., 12.]]),
 array([[ 1.,  2.,  3., 10.],
        [ 5.,  6.,  7., 11.],
        [ 7.,  8.,  9., 12.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{c. Deleting Rows/Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:c-deleting-rows-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Delete the first row (index 0)}
\PYG{n}{matrix\PYGZus{}without\PYGZus{}first\PYGZus{}row} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{delete}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Delete the second column (index 1)}
\PYG{n}{matrix\PYGZus{}without\PYGZus{}second\PYGZus{}column} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{delete}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{matrix\PYGZus{}without\PYGZus{}first\PYGZus{}row}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}without\PYGZus{}second\PYGZus{}column}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[5., 6., 7.],
        [7., 8., 9.]]),
 array([[1., 3.],
        [5., 7.],
        [7., 9.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{d. Replacing Rows/Columns}
\label{\detokenize{lessons/Intro_to_Matrices_in_NumPy:d-replacing-rows-columns}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Replace the first row}
\PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Replace the third column}
\PYG{n}{matrix}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]}

\PYG{n}{matrix}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[10., 11., 13.],
       [ 5.,  6., 14.],
       [ 7.,  8., 15.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Matrix indices warmup}
\label{\detokenize{lessons/Matrices_Index_Warmup-Student:matrix-indices-warmup}}\label{\detokenize{lessons/Matrices_Index_Warmup-Student::doc}}

\section{First, About python \sphinxstyleliteralintitle{\sphinxupquote{range(a,b)}}}
\label{\detokenize{lessons/Matrices_Index_Warmup-Student:first-about-python-range-a-b}}
\sphinxAtStartPar
Run the following and make sure you understand the output

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[2, 3, 4, 5, 6, 7, 8, 9]
[2, 5, 8]
[10, 9, 8, 7, 6, 5, 4, 3]
[10, 7, 4]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Now for the matrix challenge}
\label{\detokenize{lessons/Matrices_Index_Warmup-Student:now-for-the-matrix-challenge}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Write nested loops to create each of the following 5x5 matrices, starting from a zero matrix. Use ‘c’ and ‘r’ as the names of your index variables (this really helps your brain.) Use a counter, too! Your counter should \sphinxstyleemphasis{always} start at 1, and your code should always look like this, with no added lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n}{A}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}
A = \begin{bmatrix}
  1 &  0 &  0 &  0 &  0\\
  2 &  6 &  0 &  0 &  0\\
  3 &  7 &  10 &  0 &  0\\
  4 &  8 &  11 &  13 &  0\\
  5 &  9 &  12 &  14 &  15
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Solution 1 Here}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
B=\begin{bmatrix}
  0 &  0 &  0 &  0 &  0\\
  1 &  0 &  0 &  0 &  0\\
  2 &  5 &  0 &  0 &  0\\
  3 &  6 &  8 &  0 &  0\\
  4 &  7 &  9 &  10 &  0
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Solution 2 Here}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
C = \begin{bmatrix}
  15 &  14 &  12 &  9 &  5\\
  0 &  13 &  11 &  8 &  4\\
  0 &  0 &  10 &  7 &  3\\
  0 &  0 &  0 &  6 &  2\\
  0 &  0 &  0 &  0 &  1
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{C} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Solution 3 Here}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
D=\begin{bmatrix}
  0 &  10 &  9 &  7 &  4\\
  0 &  0 &  8 &  6 &  3\\
  0 &  0 &  0 &  5 &  2\\
  0 &  0 &  0 &  0 &  1\\
  0 &  0 &  0 &  0 &  0
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{D} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Solution 4 Here}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{D}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Gaussian Elimination}
\label{\detokenize{lessons/Gaussian_Elimination-student:gaussian-elimination}}\label{\detokenize{lessons/Gaussian_Elimination-student::doc}}
\sphinxAtStartPar
Gaussian elimination is an algorithm for solving  a linear system by matrix operations. You will write code that performs Gaussian elimination on a solvable system and returns the solution. First, we work through an instructive example.
\begin{equation*}
\begin{split}
\begin{aligned}
x + 2y - z &= 1 \\
2x - y + 3z &= 5 \\
3x + y + 3z &= 10
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we’ll solve this system using reduced row echelon form (RREF).


\section{Step 1: Write the Augmented Matrix}
\label{\detokenize{lessons/Gaussian_Elimination-student:step-1-write-the-augmented-matrix}}
\sphinxAtStartPar
The augmented matrix for this system is:
\$\(
\begin{pmatrix}
1 & 2 & -1 & \vert & 1 \\
2 & -1 & 3 & \vert & 5 \\
3 & 1 & 3 & \vert & 10
\end{pmatrix}
\)\$


\section{Step 2: Apply Row Operations to Achieve RREF}
\label{\detokenize{lessons/Gaussian_Elimination-student:step-2-apply-row-operations-to-achieve-rref}}
\sphinxAtStartPar
We’ll perform row operations to transform the matrix into reduced row echelon form (RREF).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the pivot in the first row (top\sphinxhyphen{}left corner) a 1.}\\
This is already 1, so no changes are needed.

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the first column below the pivot zeros.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add \sphinxhyphen{}2 times the first row to the second row:
\(R_2 \rightarrow R_2 - 2R_1\)
\begin{equation*}
\begin{split}
     \begin{pmatrix}
     1 & 2 & -1 & \vert & 1 \\
     0 & -5 & 5 & \vert & 3 \\
     3 & 1 & 3 & \vert & 10
     \end{pmatrix}
     \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Add \sphinxhyphen{}3 times the first row to the third row:
\(R_3 \rightarrow R_3 - 3R_1\)
\begin{equation*}
\begin{split}
     \begin{pmatrix}
     1 & 2 & -1 & \vert & 1 \\
     0 & -5 & 5 & \vert & 3 \\
     0 & -5 & 6 & \vert & 7
     \end{pmatrix}
     \end{split}
\end{equation*}
\end{itemize}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the pivot in the second row a 1.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Divide the second row by \sphinxhyphen{}5:
\(R_2 \rightarrow \frac{1}{-5}R_2\)
\$\(\begin{pmatrix}
1 & 2 & -1 & \vert & 1 \\
0 & 1 & -1 & \vert & -\frac{3}{5} \\
0 & -5 & 6 & \vert & 7
\end{pmatrix}
\)\$

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the second column below the pivot zeros.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add 5 times the second row to the third row:
\(R_3 \rightarrow R_3 + 5R_2\)
\begin{equation*}
\begin{split}\begin{pmatrix}
     1 & 2 & -1 & \vert & 1 \\
     0 & 1 & -1 & \vert & -\frac{3}{5} \\
     0 & 0 & 1 & \vert & 4
     \end{pmatrix}
     \end{split}
\end{equation*}
\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the third column above the pivot zeros.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add 1 times the third row to the second row:
\(R_2 \rightarrow R_2 + 1R_3\)
\begin{equation*}
\begin{split}\begin{pmatrix}
     1 & 2 & -1 & \vert & 1 \\
     0 & 1 & 0 & \vert & \frac{17}{5} \\
     0 & 0 & 1 & \vert & 4
     \end{pmatrix}
     \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Add 1 times the third row to the first row:
\(R_1 \rightarrow R_1 + 1R_3\)
\begin{equation*}
\begin{split}\begin{pmatrix}
     1 & 2 & 0 & \vert & 5 \\
     0 & 1 & 0 & \vert & \frac{17}{5} \\
     0 & 0 & 1 & \vert & 4
     \end{pmatrix}
     \end{split}
\end{equation*}
\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Make the second column above the pivot zeros.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add \sphinxhyphen{}2 times the second row to the first row:
\(R_1 \rightarrow R_1 - 2R_2\)
\begin{equation*}
\begin{split}
     \begin{pmatrix}
     1 & 0 & 0 & \vert & -\frac{9}{5} \\
     0 & 1 & 0 & \vert & \frac{17}{5} \\
     0 & 0 & 1 & \vert & 4
     \end{pmatrix}
     \end{split}
\end{equation*}
\end{itemize}

\end{enumerate}


\section{Step 3: Extract the solution}
\label{\detokenize{lessons/Gaussian_Elimination-student:step-3-extract-the-solution}}
\sphinxAtStartPar
The system has a unique solution, given by the final column.
\begin{equation*}
\begin{split}
x = -\frac95, \quad y = -\frac{17}{5}, \quad z = 4
\end{split}
\end{equation*}

\section{Coding}
\label{\detokenize{lessons/Gaussian_Elimination-student:coding}}
\sphinxAtStartPar
Write a method \sphinxcode{\sphinxupquote{system\_solve(A,b)}} that solves the linear system \sphinxstylestrong{Ax = b} using Gaussian elimination. You may assume the solution exists and is unique. \sphinxstylestrong{A} should be an \(n \times n\) coefficient matrix and \sphinxstylestrong{b} is an \(n \times 1\) column vector. Some example input is given for you.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{figure.dpi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{300} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} for high\PYGZhy{}dpi displays. edit as needed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} The following line creates the augmented matrix \PYGZdl{}(A | b)\PYGZdl{}. You should use this in your method}
\PYG{n}{AA}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{[}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The following cell will check your code on 10 random 5x5 matrices

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{A}\PYG{n+nd}{@x}
    \PYG{k}{assert}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{system\PYGZus{}solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{5}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{n}{b} \PYG{o}{=} \PYG{n}{A}\PYG{n+nd}{@x}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{5} \PYG{k}{assert}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{system\PYGZus{}solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}system\PYGZus{}solve\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Measuring Error}
\label{\detokenize{lessons/Gaussian_Elimination-student:measuring-error}}
\sphinxAtStartPar
The Gaussian Elimination algorithm has an error that increases with the size of the input matrix. In this section you will approximate the rate at which that error grows. Assume the error can be modeled by a polynomial \$\( err(N) \sim N^k \)\$

\sphinxAtStartPar
where \(N\) is the number of unknowns in the linear system and \(k\) is a constant to be determined. It should be noted that in general the error term depends on the relative sizes of the elements in the coefficient matrix. We are choosing them to be random from \([0,1]\) so they will usually behave reasonably the same and so the problem is simplified in our case.


\subsection{Approach}
\label{\detokenize{lessons/Gaussian_Elimination-student:approach}}
\sphinxAtStartPar
You will calculate the error in your linear system solver on several systems up to size \(N=1000\). For each size \(N\) you will solve 10 random systems and average the error \(e(N)\) over the 25 runs. You will then find a polynomial fit for the dataset \(N\) vs. \(e(N)\).

\sphinxAtStartPar
Write a method that takes as parameters the matrix size \(N\) and the number of repetitions to compute. Create two random uniform matrices: \(A\) and \(x\) (uniformly random over \([0,1]\), by using \sphinxcode{\sphinxupquote{np.random.rand}}. Compute \(b = Ax\). Use your linear solver to find \(\tilde{x}\) given \(A,b\) and determine the length of the error vector \(x - \tilde{x}\). Do this for each repetition and return the \sphinxstyleemphasis{median} error (length of the error vector). We are using the \sphinxstylestrong{median} instead of the mean because the mean is too sensitive to outliers and this investigation is rife with outliers!

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Now collect data on various values of \(N\) up to 1000. Be judicious: this problem takes a while to solve for large matrices. You should end up with a vector \(X\) that contains matrix sizes (\(N\)) up to 1000 and \(Y\) that contains the average error \(e(N)\).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Now create a scatter plot of \(N\) vs \(e(N)\). An example plot is shown here
\sphinxincludegraphics{{error-scatterplot}.png}.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\section{Regression}
\label{\detokenize{lessons/Gaussian_Elimination-student:regression}}
\sphinxAtStartPar
You have written a regression routine before, but we will use some built into numpy. Here’s sample code for doing a quadratic regression

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} x data as numpy array or python list}
\PYG{n}{y} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} y data as numpy array or python list}
\PYG{n}{coefficients} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{polyfit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 2 indicates quadratic}
\PYG{n}{a2}\PYG{p}{,} \PYG{n}{a1}\PYG{p}{,} \PYG{n}{a0} \PYG{o}{=} \PYG{n}{coefficients} \PYG{c+c1}{\PYGZsh{} in decreasing order of powers}
\PYG{n}{quadratic\PYGZus{}model} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{poly1d}\PYG{p}{(}\PYG{n}{coefficients}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} make a2x\PYGZca{}2 + a1x + a0}
\PYG{n}{y\PYGZus{}fit} \PYG{o}{=} \PYG{n}{quadratic\PYGZus{}model}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} now y\PYGZus{}fit is a vector}
\end{sphinxVerbatim}

\sphinxAtStartPar
First you should compute a quadratic regression and superimpose the resulting parabola on a scatterplot of the data

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{A regression problem and a solution}
\label{\detokenize{lessons/Gaussian_Elimination-student:a-regression-problem-and-a-solution}}
\sphinxAtStartPar
Depending on your data the parabola you’ve plotted may or may not look like a decent fit. But it has one glaring problem. By finding a quadratic fit we are assuming \(O(N^2)\) growth of our error term. But it could be \(O(n^3)\) or \(O(n^{2.3})\). What we want to find is the best \sphinxstylestrong{exponent} \(O(n^k)\) for polynomial growth. This is the perfect time to use a log\sphinxhyphen{}log plot. If you transform your data \(x_{log} = \log(x)\) and \(y_{log} = \log(y)\) and perform a linear fit, the slope of the best fit line tells you the order of growth \(k\) (derivation of this is discussed in class.)

\sphinxAtStartPar
You should find the best log\sphinxhyphen{}log plot slope. Then make a scatter plot of the values \sphinxcode{\sphinxupquote{x\_log}} and \sphinxcode{\sphinxupquote{y\_log}} along with the best fit line. Above the graph print the coefficients of the plot and state your best estimate of the growth rate \(err(N) \sim N^k\)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Finally, find the correlation coefficient for \sphinxcode{\sphinxupquote{x\_log}} and \sphinxcode{\sphinxupquote{y\_log}}. What amount of the variance is explained by your linear model? (There are several built in methods than can find this value)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_solution}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Your code goes here. Insert cells as needed.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\chapter{Log\sphinxhyphen{}Log Regression}
\label{\detokenize{lessons/LogLogRegression:log-log-regression}}\label{\detokenize{lessons/LogLogRegression::doc}}
\sphinxAtStartPar
Linear Regression is quite capable of solving non\sphinxhyphen{}linear problems if you know how to properly pre\sphinxhyphen{}process your data. Let’s look at a few types of datasets we can regress by using logarithmic transformations.


\section{Regular Linear Regression}
\label{\detokenize{lessons/LogLogRegression:regular-linear-regression}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
First let’s analyze a typical linear dataset

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{5} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{m}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{polyfit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y\PYGZus{}fit} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{poly1d}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y\PYGZus{}fit}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} note the semicolon here. what does it do?}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Linear y vs x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3b8d65050f2d8ea42fac2f233889e0b28e8be2c8714411b64ced2cb7e4aa2eed}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And find \(r\) and \(m\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{corrcoef}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.0845960050150274
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1.        , 0.86180876],
       [0.86180876, 1.        ]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Exponential Regression}
\label{\detokenize{lessons/LogLogRegression:exponential-regression}}
\sphinxAtStartPar
If we believe \(y = Ca^x\) then by regressing \(x\) against \(\ln y\) we can determine \(a\).
\begin{equation*}
\begin{split}
\begin{array}{rl}
y &=& Ca^x \\
\ln y &=& \ln C + x \ln a \\
\end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
This is a line with slope \(\ln a\) and intercept \(\ln C\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{n}{x}

\PYG{c+c1}{\PYGZsh{} add noise, but keep y \PYGZgt{} 0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{noise}  \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{gauss}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{n}{noise} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{break}
    \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{noise}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exponential correlation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{7}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6}     \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{7}         \PYG{n}{noise}  \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{gauss}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8}         \PYG{k}{if} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{n}{noise} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9}             \PYG{k}{break}

\PYG{n+ne}{NameError}: name \PYGZsq{}random\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} transform y}
\PYG{n}{y\PYGZus{}t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} this is ln}

\PYG{n}{m}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{polyfit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y\PYGZus{}t}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y\PYGZus{}fit} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{poly1d}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y\PYGZus{}t}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y\PYGZus{}fit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ln(y) vs }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{40490c2d1bc358c22e40773e33120c20b87dfe776cf19b7835476c44adbce9c7}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And find \(r\) and \(a\) and \(C\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{base = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{corrcoef}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
base =  2.9975765382313955
C =  0.24812105741218246
r = 0.95069612414204
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Log\sphinxhyphen{}Log Regression}
\label{\detokenize{lessons/LogLogRegression:id1}}
\sphinxAtStartPar
If we believe \(y = Cx^k\) then by regressing \(\ln x\) against \(\ln y\) we can determine \(k\).
\begin{equation*}
\begin{split}
\begin{array}{rl}
y &=& Cx^k \\
\ln y &=& \ln C + k \ln x \\
\end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
This is a line with slope \(k\) and intercept \(\ln C\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{3.14}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{noise}  \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{gauss}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{n}{noise} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{break}
    \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{noise}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Polynomial correlation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{9e045fc7bf81ad15d63cdbb10df4d1c8bbb5a75f1f1ef1c69732783135f7d1a2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} check y for 0}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} transform y and x}
\PYG{n}{x\PYGZus{}t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{y\PYGZus{}t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{m}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{polyfit}\PYG{p}{(}\PYG{n}{x\PYGZus{}t}\PYG{p}{,}\PYG{n}{y\PYGZus{}t}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y\PYGZus{}fit} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{poly1d}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x\PYGZus{}t}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x\PYGZus{}t}\PYG{p}{,}\PYG{n}{y\PYGZus{}t}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}t}\PYG{p}{,}\PYG{n}{y\PYGZus{}fit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ln(y) vs ln(x)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
73.2177132494846
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{34dbefdab1af83771fa8b43f1e0ac043570b68502745ea1c160f0f4188bdb70d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And find \(r\) and \(a\) and \(C\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{degree = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{,} \PYG{n}{m}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{corrcoef}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
degree =  3.133547086987462
C =  10.03662528625072
r = 0.9376281240390777
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Strassen’s Algorithm (Optional Extension)}
\label{\detokenize{lessons/Strassen-Lab:strassen-s-algorithm-optional-extension}}\label{\detokenize{lessons/Strassen-Lab::doc}}
\sphinxAtStartPar
Matrix multiplication in the naive implementation requires \(O(n^3)\) floating point
operations on a matrix with \(n^2\) entries. In fact it seems unlikely one could do better.
Each of the \(n^2\) entries in the product requires a dot product of two length \(n\) vectors.
Yet in 1969, Volken Strassen shocked numerical analysists with his algorithm requiring
\(O(n^{\log_2{7}}) \approx O(n^{2.73})\) floating point operations. The search for a lower bound
on the complexity of matrix multiplication continues today, with recent results hovering around \(O(n^{2.3})\).


\section{Goal}
\label{\detokenize{lessons/Strassen-Lab:goal}}
\sphinxAtStartPar
You will implement Strassen’s algorithm using Python and numpy. You will then
perform tests to verify the achieved asymptotic running time of Strassen is actually lower than
the running time of your previously implemented (non\sphinxhyphen{}numpy) matrix multiplication.


\section{Details}
\label{\detokenize{lessons/Strassen-Lab:details}}
\sphinxAtStartPar
Read up on Strassen online (wikipedia has a good article, for example) and implement his algorithm using numpy. \sphinxstylestrong{Your algorithm can assume \(n=2^k\)}. Making Strassen work otherwise requires really messy memory management best left to C\sphinxhyphen{}type languages. Test correctness of your code on several random matrices by comparing your output to numpy (\(A @ B\)). To simplify things, you should work with \sphinxstylestrong{integer} matrices only (floating\sphinxhyphen{}point introduces rounding errors that we don’t want to deal with.)

\sphinxAtStartPar
Once you know it works, do some regression analysis on your original algorithm and Strassen and compare their running times. The easiest way to do this is in Python is with \sphinxcode{\sphinxupquote{timeit.timeit}}. Here’s an example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{timeit}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{timeit}\PYG{o}{.}\PYG{n}{timeit}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A@A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{number}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n+nb}{globals} \PYG{o}{=} \PYG{n+nb}{globals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{25}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{timeit}} function evaluates the first string argument. If the string references
values defined elsewhere you need to pass in the current state of the python interpreter
which is what the \sphinxcode{\sphinxupquote{globals}} argument is for. Note we divide by 25 to get an average time per operation. (Running times are usually very centrally distributed so you need not worry about outliers – the mean is a perfectly good measure of center.)

\sphinxAtStartPar
Warning – these algorithms run pretty quickly on \(n=2^6\) or \(n=2^7\) but after that become \sphinxstyleemphasis{very} slow. You will need to proceed judiciously but also gather enough data for a valid conclusion. (In my testing I let my Lenovo laptop run for about 30 minutes).

\sphinxAtStartPar
\sphinxstyleemphasis{N.B.}: Strassen is recursive and has a base case. Please use the base case \(n=4\) and return \sphinxcode{\sphinxupquote{A@B}}. This will ensure we have similar results.


\section{Results}
\label{\detokenize{lessons/Strassen-Lab:results}}
\sphinxAtStartPar
You should graph the averaged running times of Strassen and Naive multiplication on the same graph. Then perform an appropriate regression analysis to determine the respective orders of growth to prove Strassen is asymptotically faster. Support your conclusions with calculations and graphs. (See the Gaussian elimination lab for regression operations).

\sphinxAtStartPar
Finally, just for humility’s sake, print out a nicely formatted table comparing the above two algorithms with numpy’s built in multiply operation. (Don’t feel too bad, it’s using a compiled C library).

\sphinxstepscope


\chapter{Gauss Presentation}
\label{\detokenize{lessons/Gauss:gauss-presentation}}\label{\detokenize{lessons/Gauss::doc}}
\sphinxAtStartPar
Carl Friedrich Gauss was sickeningly brilliant. Prepare a 10\sphinxhyphen{}15 minute lecture on the
accomplishments of Gauss, focusing primarily on mathematics. Give a moderately technical presentation that your classmates will understand that highlight a few of his greatest hits. This should be a whiteboard presentation – not powerpoint! (If you need a couple slides to show complex diagrams that would be OK, but not needed). This should be presented next Tuesday or Thursday and the beginning of class.

\sphinxstepscope


\chapter{Matrix Inversion}
\label{\detokenize{lessons/inversion:matrix-inversion}}\label{\detokenize{lessons/inversion::doc}}
\sphinxAtStartPar
You can invert a matrix \(A\) by creating the \(n \times 2n\) matrix \([A \quad I]\). This means you stack \(A\) right next to the \(n \times n\) identity matrix. Then perform Gaussian Elimination on \(A\) just like you were solving a system of equations. You will end up with the matrix \([I \quad A^{-1}]\). Sounds easy. But matrix inversion is highly unstable numerically. You will investigate in this lab.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The Hilbert matrix \(a_{ij} = 1/(i+j+1)\) is notoriously unstable. (Read about it online; note that our definition uses “+1” because python and math are different sometimes.)

\item {} 
\sphinxAtStartPar
Implement matrix inversion and check it on some small \textasciitilde{}\textasciitilde{}Hilbert matrices\textasciitilde{}\textasciitilde{} \sphinxstylestrong{random real matrices}. (Check by verifying \(AA^{-1} = I\). This will \sphinxstyleemphasis{not} be exact so account for rounding errors).

\item {} 
\sphinxAtStartPar
Make a plot of matrix size vs. error. Error is defined as the Frobenius norm of the matrix \((AA^{-1} - I)\) so \(err = || (AA^{-1} - I) ||_F\). (It’s trivial to do in numpy so look it up!)

\item {} 
\sphinxAtStartPar
Implement GEPP (Gaussian elimination with partial pivoting) and make a similar plot to part 2. You should see the errors decrease with GEPP.

\item {} 
\sphinxAtStartPar
Finally, plot the error in the inherent \sphinxcode{\sphinxupquote{np.linalg.inv}} function and compare it to yours.

\end{enumerate}

\sphinxAtStartPar
You can seen an example of GEPP \sphinxhref{https://web.mit.edu/10.001/Web/Course\_Notes/GaussElimPivoting.html}{here}. Note they do NOT make the diagonal all 1’s like we do – but you can keep doing it our way. The main idea is the pivoting.

\sphinxAtStartPar
\sphinxstylestrong{I wrote this after a short investigation of Hilbert matrices which are known to be poorly conditioned (the condition number grows quite predictably, if you want to look it up). I assumed that GEPP would behave poorly in direct correlation to the condition number but it does \sphinxstyleemphasis{not}. Random matrices provide a much cleaner pattern.}

\sphinxstepscope


\chapter{Running Time Analysis}
\label{\detokenize{lessons/Running_Time_Analysis:running-time-analysis}}\label{\detokenize{lessons/Running_Time_Analysis::doc}}
\sphinxAtStartPar
Use numpy and pandas for this lab. Download the csv file “matrix\_multiply\_times.csv” and put it in this folder

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}wget\PYG{+w}{ }https://aet\PYGZhy{}cs.github.io/white/ML/lessons/matrix\PYGZus{}multiply\PYGZus{}times.csv
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2024\PYGZhy{}10\PYGZhy{}03 20:02:17\PYGZhy{}\PYGZhy{}  https://aet\PYGZhy{}cs.github.io/white/ML/lessons/matrix\PYGZus{}multiply\PYGZus{}times.csv
Resolving aet\PYGZhy{}cs.github.io (aet\PYGZhy{}cs.github.io)... 185.199.108.153, 185.199.111.153, 185.199.110.153, ...
Connecting to aet\PYGZhy{}cs.github.io (aet\PYGZhy{}cs.github.io)|185.199.108.153|:443... 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
connected.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
HTTP request sent, awaiting response... 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
200 OK
Length: 897 [text/csv]
Saving to: ‘matrix\PYGZus{}multiply\PYGZus{}times.csv.5’


          matrix\PYGZus{}mu   0\PYGZpc{}[                    ]       0  \PYGZhy{}\PYGZhy{}.\PYGZhy{}KB/s               
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
matrix\PYGZus{}multiply\PYGZus{}tim 100\PYGZpc{}[===================\PYGZgt{}]     897  \PYGZhy{}\PYGZhy{}.\PYGZhy{}KB/s    in 0.07s   

2024\PYGZhy{}10\PYGZhy{}03 20:02:18 (13.3 KB/s) \PYGZhy{} ‘matrix\PYGZus{}multiply\PYGZus{}times.csv.5’ saved [897/897]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Read the csv as a DataFrame and display it (\sphinxcode{\sphinxupquote{pd.read\_csv}} will help)

\sphinxAtStartPar
Drop the column “Matrix row size” and save it as a \sphinxstyleemphasis{new} dataframe (I like to use the names df,df2,df3,etc as I do this kind of work) (read about \sphinxcode{\sphinxupquote{df.drop}})

\sphinxAtStartPar
Plot the data frame data, \sphinxcode{\sphinxupquote{x}} is the ‘exp’ column, the \sphinxcode{\sphinxupquote{y}} values are the other columns (times in seconds). Use pandas e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df2}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Add new columns that represent the log transformations of the existing time columns, because we want a log\sphinxhyphen{}log analysis eventually. Here’s an example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{strass\PYGZus{}log}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Strassen Time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} PLEASE use tab\PYGZhy{}completion for this!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then \sphinxstyleemphasis{drop} the old (non\sphinxhyphen{}log) columns. Store the result in a \sphinxstyleemphasis{new} data frame that has only 5 columns (one ‘exp’ and four log\sphinxhyphen{}times)

\sphinxAtStartPar
Plot the new dataframe line plots: x vs. log\sphinxhyphen{}times

\sphinxAtStartPar
Now we want to do a log\sphinxhyphen{}log regression. You will need numpy. Luckily pandas and numpy play nicely together. For example you could say

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{}some dataframe}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{coeffs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{polyfit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
And you can even add in things like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{x}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
for example

\sphinxAtStartPar
Do the log\sphinxhyphen{}log regressions and print out a table in this format

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n}{algorithm} \PYG{n}{name}\PYG{p}{,} \PYG{n}{rate} \PYG{n}{of} \PYG{n}{growth} \PYG{p}{(}\PYG{n}{degree}\PYG{p}{)}\PYG{p}{,} \PYG{n}{corrcoeff}
\end{sphinxVerbatim}

\sphinxAtStartPar
Recall you can get corrcoeff from

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{corrcoeff}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
You should notice some problems in your results, and the problems will depend on what you did above. What did you expect and how does it compare to what you got? Now your
job is to fix it. Here are some things to consider
\begin{itemize}
\item {} 
\sphinxAtStartPar
Some regression may not even work because it doesn’t like the data

\item {} 
\sphinxAtStartPar
Are the units of your “x” column in the regression correct? (They should be log of the row length)

\item {} 
\sphinxAtStartPar
What base are you using with the logs and are you consistent?

\item {} 
\sphinxAtStartPar
Small values of \(n\) might be skewing the data. Filter them out (see below)

\item {} 
\sphinxAtStartPar
Rows with NA value are also problematic. Drop them judiciously

\item {} 
\sphinxAtStartPar
Make sure you understand how to interpret the regression equations and numpy results

\end{itemize}

\sphinxAtStartPar
Work through the Pandas filtering tricks section and then do your analysis afterwards.


\section{Pandas filtering tricks}
\label{\detokenize{lessons/Running_Time_Analysis:pandas-filtering-tricks}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{log\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log2}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/pewhite/github/aet\PYGZhy{}cs/aet\PYGZhy{}cs.github.io/white/ML/env/lib/python3.11/site\PYGZhy{}packages/pandas/core/arraylike.py:399: RuntimeWarning: divide by zero encountered in log2
  result = getattr(ufunc, method)(*inputs, **kwargs)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      x  y     log\PYGZus{}y
0   1.0  5  2.321928
1   2.0  4  2.000000
2   3.0  3  1.584963
3  10.0  4  2.000000
4  20.0  1  0.000000
5 \PYGZhy{}10.0  0      \PYGZhy{}inf
6   NaN  9  3.169925
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can index columns by boolean comparisons

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{n}{df}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      x  y  log\PYGZus{}y
3  10.0  4    2.0
4  20.0  1    0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This just returns a list of T/F values

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0    False
1    False
2    False
3     True
4     True
5    False
6    False
Name: x, dtype: bool
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here’s a different syntax

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0     True
1     True
2     True
3    False
4    False
5     True
6    False
Name: x, dtype: bool
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{log\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{inf}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0    False
1    False
2    False
3    False
4    False
5     True
6    False
Name: log\PYGZus{}y, dtype: bool
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Boolean ‘not’ is \sphinxcode{\sphinxupquote{\textasciitilde{}}} in pandas

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{log\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{inf}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      x  y     log\PYGZus{}y
0   1.0  5  2.321928
1   2.0  4  2.000000
2   3.0  3  1.584963
3  10.0  4  2.000000
4  20.0  1  0.000000
6   NaN  9  3.169925
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{isna}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      x  y     log\PYGZus{}y
0   1.0  5  2.321928
1   2.0  4  2.000000
2   3.0  3  1.584963
3  10.0  4  2.000000
4  20.0  1  0.000000
5 \PYGZhy{}10.0  0      \PYGZhy{}inf
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Analysis}
\label{\detokenize{lessons/Running_Time_Analysis:analysis}}
\sphinxAtStartPar
Complete your final analysis here of the 4 running times by using techniques you have learned in this notebook. Print out your final table of the the running time comparisons, based on your best justifiable arguments

\sphinxstepscope


\part{Next Steps}

\sphinxstepscope


\chapter{Reading for Research}
\label{\detokenize{lessons/reading:reading-for-research}}\label{\detokenize{lessons/reading::doc}}
\sphinxAtStartPar
I believe there are three pillars of research: specific content expertise, broad knowledge of the field, and an ability to identify relevant problems that need to be solved. (I’m still thinking
for a catchy three\sphinxhyphen{}word phrase for this.)

\sphinxAtStartPar
You’re developing specific expertise in Machine Learning by taking this course. You
are learning to identify relevant problems by adding to your Money List. And now we
will work on broad knowledge by regularly reading publications in the field of
computer science.

\sphinxAtStartPar
I’ve collected several good links on the \sphinxhref{https://aet-cs.github.io/white/ML/}{class GitHub Page} under the heading \sphinxhref{https://aet-cs.github.io/white/ML/background/}{Research}. For this assignment (which will repeat regularly, maybe every 2 weeks or so), you should read some articles and choose one to present to the class.

\sphinxAtStartPar
The presentation will usually be very informal – we’ll just go around the room and ask you to stay at your seat and give us a quick summary. Tell us what the article is about, what problem they’re solving, what motivated them, and what their solution is. Know the article well enough to
give specifics and respond to questions.

\sphinxAtStartPar
I know that this kind of self\sphinxhyphen{}directed reading is one of the very best ways to get inspired
to learn more about a field and to find new problems to solve. I also hope that your brief presentations to the class will help inspire the rest of the class. We’ll all hear about
a dozen different new results in computer science. It should be lots of fun!

\sphinxAtStartPar
Specifically for next week, please select one article from the links above and be ready to tell us about it on probably Monday. All the links are good, but the \sphinxhref{https://cacm.acm.org/}{first one} (Communications of the ACM) might be the best one\sphinxhyphen{}stop\sphinxhyphen{}shop. It depends on what you like, though.

\sphinxstepscope


\chapter{Hobo Data, Student Version}
\label{\detokenize{lessons/Hobo_Student:hobo-data-student-version}}\label{\detokenize{lessons/Hobo_Student::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn} \PYG{k}{as} \PYG{n+nn}{sk}
\PYG{k+kn}{import} \PYG{n+nn}{cv2}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
We’ll have three groups working on different parts of the \sphinxhref{https://sites.google.com/lcps.org/hobosensordatabase/home}{HOBO data} (described below).
\begin{itemize}
\item {} 
\sphinxAtStartPar
Group 1 will extract sensor coordinates from a satellite image screenshot. You will produce a funtion that returns screen cooriadte for x,y pairs as in:
\begin{itemize}
\item {} 
\sphinxAtStartPar
pos(“A”,”30”) = 143,299

\end{itemize}

\item {} 
\sphinxAtStartPar
Group two will ingest and clean the all the relevant data and store it in arrays indexed by <x,y,t> (horizontal, vertical, time, so that a user can query
\begin{itemize}
\item {} 
\sphinxAtStartPar
“A, 30, 01/27/2022 17:28:08” and return the reading \sphinxhyphen{}0.95	34.40

\end{itemize}

\item {} 
\sphinxAtStartPar
Group 3 will explor 3D plots in matplot lib specifically contour and surface plots, and then animate the plots as parameters change. You can start with variants of \(y = e^{-x^2} \sin(t)\) and \(z =4 \sin (t) e^{-x^2-y^2} \cos \left(4 x^2+4 y^2\right)\)

\end{itemize}


\section{Part 1: Extracting Coordinates}
\label{\detokenize{lessons/Hobo_Student:part-1-extracting-coordinates}}
\sphinxAtStartPar
There’s some data being collected \sphinxhref{https://sites.google.com/lcps.org/hobosensordatabase/home}{here} Read about the hobo data first. Then identify the data for the “red” grid of sensors for ACL. in part 1 you will approximate the coordinates of these sensors by analyzing a screenshot. You’re using the openCV library “cv2” which should be installed in this environment.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pic} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red\PYGZus{}sensor\PYGZus{}image.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{IMREAD\PYGZus{}COLOR}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[ WARN:0@0.024] global loadsave.cpp:241 findDecoder imread\PYGZus{}(\PYGZsq{}red\PYGZus{}sensor\PYGZus{}image.png\PYGZsq{}): can\PYGZsq{}t open/read file: check file path/integrity
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Find the shape and then select a submatrix that is square but doesn’t cut off any data

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pic}\PYG{o}{.}\PYG{n}{shape}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{AttributeError}\PYG{g+gWhitespace}{                            }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{pic}\PYG{o}{.}\PYG{n}{shape}

\PYG{n+ne}{AttributeError}: \PYGZsq{}NoneType\PYGZsq{} object has no attribute \PYGZsq{}shape\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pic} \PYG{o}{=} \PYG{n}{pic}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{1180}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{pic}\PYG{o}{.}\PYG{n}{shape}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(1180, 1180, 3)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Convert the image from BGR to RGB (openCV uses a different ordering of color data) and then display. Use the commands \sphinxcode{\sphinxupquote{cv2.cvtColor}} and \sphinxcode{\sphinxupquote{plt.imshow()}}

\sphinxAtStartPar
To find the red dots, we choose to analyse just the red layer of pixel information. Split the image into RGB channels using \sphinxcode{\sphinxupquote{cv2.split}} and dislay the red channel only, as grayscale.

\sphinxAtStartPar
You see the red pixels are nearly white and the background is nearly black. We want to crush this image into 0s and 255s for black and white, so the red dots really pop. Use matplotlib filtering syntax (much like pandas filtering). Any pixel with a red above 200 should become 255. Anything below should be 0. (Be sure to \sphinxstylestrong{copy} your red matrix first in case you mess up.)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} print the red matrix here as a sanity check}
\PYG{c+c1}{\PYGZsh{} and its size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Plot your black and white matrix here}


\subsection{Machine Learning – KMeans}
\label{\detokenize{lessons/Hobo_Student:machine-learning-kmeans}}
\sphinxAtStartPar
We need to know the location of the centers of these dots, in the coordinate space of the picture. the kMeans algorithm is perfect for this. It finds local centers of clusters. I’ll get you started with a list of all the pixels that have white centers. The KMeans algorithm will determine all the centers and list them for you as coorindate pairs. You should tell it how many centers you’re looking for. Then create a plot with (a) the original image and (b) the centers plotted as white ‘x’ symbols (look at plt.scatter(marker = …))

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{cluster} \PYG{k+kn}{import} \PYG{n}{KMeans}

\PYG{c+c1}{\PYGZsh{} Extract the coordinates of the white pixels (where red == 255)}
\PYG{n}{white\PYGZus{}pixels} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{column\PYGZus{}stack}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{red2} \PYG{o}{==} \PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{white\PYGZus{}pixels}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[  30,  828],
       [  30,  829],
       [  30,  830],
       ...,
       [1162,  192],
       [1162,  193],
       [1162,  194]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Apply KMeans to find the centers of the white dots}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Part 2: Ingesting Data}
\label{\detokenize{lessons/Hobo_Student:part-2-ingesting-data}}
\sphinxAtStartPar
Use pandas to read spreadsheet csv files into data frames. You will probably want to merge frames to get one big one. Then think about how to filter or aggregate the data so it’s ready to go when someone asks for a location and time – you should give it to them. (Assume their input is valid at first, but then handle the case when it isn’t)


\section{Part 3: Visualization}
\label{\detokenize{lessons/Hobo_Student:part-3-visualization}}
\sphinxAtStartPar
Read up on matplotlib 3d plotting. There are four different things here
\begin{itemize}
\item {} 
\sphinxAtStartPar
3d plots and contour plots (related)

\item {} 
\sphinxAtStartPar
animation

\item {} 
\sphinxAtStartPar
animation with 3d plots

\item {} 
\sphinxAtStartPar
saving the animation as a file

\end{itemize}

\sphinxAtStartPar
Thare are plenty of tutorials on saving a simple 2d animation. I’d do that first. Then play around with 3d contour and surface plots. Finally try to get an exported video of a 3d animation. (you might need ffmpeg, it’s easy to install on the unix side of WSL)

\sphinxAtStartPar
The goal here is to be able to take grids of data (x,y,t,z) corresponding to location and time and an output like temperature, and plot that as a 3d surface and/or contour and then animate it for a range of times.

\sphinxstepscope


\chapter{ML Book Club}
\label{\detokenize{lessons/ML_Book_Club:ml-book-club}}\label{\detokenize{lessons/ML_Book_Club::doc}}
\sphinxAtStartPar
You are a member of research book club (OK so it’s an ‘article club’ but that sounds ridiculous). Working together please pick 3 articles from the resources on \sphinxhref{https://aet-cs.github.io/white/ML/background/}{this page} that are interesting to the whole group. The articles do not have to have any common topic or thread, unless this is what the group chooses. Each group member will read one article and take notes. Note: the article should be “lengthy.” Some of the things you’ll find here are just overviews or summaries. A journal article, or something of similar heft written for a technical audience, is the target.

\sphinxAtStartPar
Next week we will meet in book club groups. Each group member will report about their article to the group. Group members can discuss the three articles and what they found interesting and inspiring about them.

\sphinxAtStartPar
As you read your chosen article, keep the following questions in mind. Try to address each of these points in your book club meeting. You may want to take some written notes to help guide your processing of the material.
\begin{itemize}
\item {} 
\sphinxAtStartPar
What inspired this article?

\item {} 
\sphinxAtStartPar
What problem does it solve?

\item {} 
\sphinxAtStartPar
What is the primary creative insight that led to the solution they’re proposing?

\item {} 
\sphinxAtStartPar
What are extensions or applications that you can think of for this research?

\item {} 
\sphinxAtStartPar
When you think about doing research, and posing research questions of your own, how has this article helped you better understand the process? (This may be difficult at first but I believe every good article teaches us about the research process.)

\end{itemize}







\renewcommand{\indexname}{Index}
\printindex
\end{document}